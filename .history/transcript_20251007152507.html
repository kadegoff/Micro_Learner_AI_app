<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Transcript</title>
    <link rel="stylesheet" href="different_computer_styles.css" />
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          sans-serif;
        background: rgba(10, 10, 10, 0.9);
        backdrop-filter: blur(25px);
        -webkit-backdrop-filter: blur(25px);
        color: #e4e4e7;
        height: 100vh;
        overflow: hidden;
        user-select: text;
        border: 1px solid rgba(255, 255, 255, 0.1);
        transition: all 0.3s ease;
        display: none !important; /* Start hidden until restored */
      }

      /* Minimize animation states */
      body.minimizing {
        animation: minimizeToControl 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94)
          forwards;
        pointer-events: none;
      }

      body.restoring {
        animation: restoreFromControl 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94)
          forwards;
      }

      @keyframes minimizeToControl {
        0% {
          transform: scale(1) translate(0, 0);
          opacity: 1;
        }
        60% {
          transform: scale(0.6) translate(200px, 300px);
          opacity: 0.8;
        }
        100% {
          transform: scale(0.1) translate(400px, 400px);
          opacity: 0;
        }
      }

      @keyframes restoreFromControl {
        0% {
          transform: scale(0.1) translate(400px, 400px);
          opacity: 0;
        }
        40% {
          transform: scale(0.6) translate(200px, 300px);
          opacity: 0.8;
        }
        100% {
          transform: scale(1) translate(0, 0);
          opacity: 1;
        }
      }

      /* Enhanced transparency when not in focus or when activity is detected */
      body.fade-mode {
        background: rgba(10, 10, 10, 0.9);
        backdrop-filter: blur(35px);
        -webkit-backdrop-filter: blur(35px);
      }

      /* Even more transparent when window is not focused */
      body.inactive {
        background: rgba(10, 10, 10, 0.3);
        backdrop-filter: blur(40px);
        -webkit-backdrop-filter: blur(40px);
      }

      .header {
        background: rgba(20, 20, 20, 0.6);
        display: flex;
        align-items: center;
        justify-content: space-between;
        -webkit-app-region: drag;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        min-height: 40px;
        transition: background 0.3s ease;
        cursor: move;
        pointer-events: auto;
      }

      body.fade-mode .header {
        background: rgba(20, 20, 20, 0.4);
      }

      body.inactive .header {
        background: rgba(20, 20, 20, 0.3);
      }

      .title {
        font-size: 13px;
        font-weight: 600;
        color: #3b82f6;
        display: flex;
        align-items: center;
        gap: 6px;
        margin-left: 15px;
        pointer-events: none;
      }

      .title::before {
        content: "üí¨";
        font-size: 16px;
      }

      .header-controls {
        display: flex;
        align-items: center;
        gap: 10px;
        -webkit-app-region: no-drag;
        height: 100%;
      }

      .window-controls {
        display: flex;
        align-items: center;
        height: 100%;
        -webkit-app-region: no-drag;
      }

      .window-control-btn {
        width: 50px;
        height: 40px;
        border: none;
        cursor: pointer;
        transition: background-color 0.15s ease;
        position: relative;
        background: transparent;
        display: flex;
        align-items: center;
        justify-content: center;
        font-family: "Segoe UI Symbol", sans-serif;
        font-size: 15px;
        color: #ffffff;
      }

      .window-control-btn:hover {
        background: rgba(255, 255, 255, 0.1);
      }

      .minimize-btn::before {
        content: "‚Äî";
        font-size: 12px;
        font-weight: normal;
        line-height: 1;
      }

      .close-btn::before {
        content: "‚úï";
        font-size: 10px;
        font-weight: normal;
        line-height: 1;
      }

      .close-btn:hover {
        background: #c42b1c;
        color: #ffffff;
      }

      /* Platform-specific styles */
      .platform-windows .window-controls {
        order: 1;
      }

      .platform-mac .window-controls {
        order: -1;
      }

      .platform-windows .minimize-btn:hover {
        background: rgba(255, 255, 255, 0.2);
      }

      .platform-windows .minimize-btn::before {
        content: "üóï";
        font-size: 12px;
      }

      .platform-windows .maximize-btn:hover {
        background: rgba(255, 255, 255, 0.2);
      }

      .platform-windows .close-btn:hover {
        background: rgba(239, 68, 68, 0.8);
      }

      .platform-windows .close-btn::before {
        content: "üóô";
        font-size: 15px;
      }

      /* Hide Mac-style controls on Windows */
      .platform-windows .window-control-btn:hover::after {
        display: none;
      }

      /* Maximized state styles */
      .maximized {
        border-radius: 0 !important;
      }

      .maximized .header {
        border-radius: 0 !important;
      }

      .maximized .content {
        border-radius: 0 !important;
      }

      .content {
        height: calc(100vh - 40px);
        overflow-y: auto;
        padding: 15px;
        -webkit-app-region: no-drag;
        border-radius: 0 0 12px 12px;
      }

      .transcript-entry {
        margin-bottom: 12px;
        padding: 12px;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 12px;
        border-left: 3px solid #3b82f6;
        animation: slideIn 0.3s ease-out;
        position: relative;
        transition: all 0.3s ease;
      }

      .transcript-entry:hover {
        background: rgba(255, 255, 255, 0.08);
        transform: translateX(4px);
      }

      @keyframes slideIn {
        from {
          opacity: 0;
          transform: translateX(-20px);
        }
        to {
          opacity: 1;
          transform: translateX(0);
        }
      }

      .timestamp {
        font-size: 10px;
        color: #71717a;
        margin-bottom: 6px;
        font-family: "SF Mono", "Monaco", "Inconsolata", monospace;
        display: flex;
        align-items: center;
        gap: 6px;
      }

      .timestamp::before {
        content: "‚è±Ô∏è";
        font-size: 12px;
      }

      .text {
        font-size: 13px;
        line-height: 1.5;
        color: #e4e4e7;
        word-wrap: break-word;
      }

      .question {
        border-left-color: #f59e0b;
        background: rgba(245, 158, 11, 0.1);
      }

      .question .text {
        color: #fbbf24;
      }

      .question .timestamp::before {
        content: "‚ùì";
      }

      .corrected-indicator {
        position: absolute;
        top: 8px;
        right: 10px;
        font-size: 10px;
        color: #10b981;
        background: rgba(16, 185, 129, 0.2);
        padding: 2px 6px;
        border-radius: 8px;
        display: flex;
        align-items: center;
        gap: 4px;
      }

      .corrected-indicator::before {
        content: "‚úì";
        font-weight: bold;
      }

      .original-text {
        font-size: 11px;
        color: #71717a;
        margin-top: 6px;
        padding-top: 6px;
        border-top: 1px solid rgba(255, 255, 255, 0.1);
        font-style: italic;
      }

      .original-text::before {
        content: "Original: ";
        color: #52525b;
      }

      .partial {
        opacity: 0.7;
        font-style: italic;
        border-left-color: #71717a;
        background: rgba(113, 113, 122, 0.1);
      }

      .partial .text {
        color: #a1a1aa;
      }

      .partial .timestamp::before {
        content: "‚è≥";
      }

      .empty-state {
        text-align: center;
        color: #52525b;
        font-size: 14px;
        margin-top: 50px;
        padding: 20px;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 12px;
      }

      .empty-state::before {
        content: "üé§";
        font-size: 48px;
        opacity: 0.5;
      }

      /* Scrollbar styles */
      ::-webkit-scrollbar {
        width: 6px;
      }

      ::-webkit-scrollbar-track {
        background: transparent;
      }

      ::-webkit-scrollbar-thumb {
        background: rgba(255, 255, 255, 0.2);
        border-radius: 3px;
      }

      ::-webkit-scrollbar-thumb:hover {
        background: rgba(255, 255, 255, 0.3);
      }

      /* Transcript statistics */
      .stats-bar {
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        height: 24px;
        background: rgba(20, 20, 20, 0.6);
        border-top: 1px solid rgba(255, 255, 255, 0.1);
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0 15px;
        font-size: 10px;
        color: #71717a;
        transition: background 0.3s ease;
      }

      body.fade-mode .stats-bar {
        background: rgba(20, 20, 20, 0.4);
      }

      body.inactive .stats-bar {
        background: rgba(20, 20, 20, 0.3);
      }

      .stat-item {
        display: flex;
        align-items: center;
        gap: 4px;
      }

      /* Responsive design */
      @media (max-width: 768px) {
        .title {
          font-size: 12px;
        }

        .transcript-entry {
          padding: 10px;
        }

        .text {
          font-size: 12px;
        }

        .timestamp {
          font-size: 9px;
        }
      }

      /* Accessibility improvements */
      @media (prefers-reduced-motion: reduce) {
        * {
          animation-duration: 0.01ms !important;
          animation-iteration-count: 1 !important;
          transition-duration: 0.01ms !important;
        }
      }

      /* Focus styles for better accessibility */
      .window-control-btn:focus {
        outline: 2px solid #3b82f6;
        outline-offset: 2px;
      }

      /* Copy to clipboard functionality */
      .transcript-entry {
        cursor: pointer;
      }

      .transcript-entry:active {
        transform: scale(0.98);
      }

      .copy-feedback {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(16, 185, 129, 0.9);
        color: white;
        padding: 8px 16px;
        border-radius: 8px;
        font-size: 12px;
        font-weight: 500;
        z-index: 1000;
        opacity: 0;
        transition: opacity 0.3s ease;
      }

      .copy-feedback.show {
        opacity: 1;
      }

      /* Enhanced visual feedback */
      .transcript-entry.copying {
        background: rgba(16, 185, 129, 0.2);
        border-left-color: #10b981;
      }

      /* Word count and timing info */
      .entry-meta {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-top: 6px;
        font-size: 10px;
        color: #71717a;
      }

      .word-count::before {
        content: "üìù";
        margin-right: 4px;
      }

      .confidence-score {
        background: rgba(59, 130, 246, 0.2);
        padding: 2px 6px;
        border-radius: 4px;
        color: #3b82f6;
      }

      .confidence-score.low {
        background: rgba(245, 158, 11, 0.2);
        color: #f59e0b;
      }

      .confidence-score.high {
        background: rgba(16, 185, 129, 0.2);
        color: #10b981;
      }

      /* Minimize notification */
      .minimize-notification {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(59, 130, 246, 0.9);
        color: white;
        padding: 12px 20px;
        border-radius: 12px;
        font-size: 14px;
        font-weight: 500;
        z-index: 2000;
        opacity: 0;
        transition: opacity 0.3s ease;
        pointer-events: none;
      }

      .minimize-notification.show {
        opacity: 1;
      }

      /* Visual feedback for dragging */
      .header.dragging {
        background: rgba(59, 130, 246, 0.3);
        border-bottom-color: #3b82f6;
      }
    </style>
  </head>
  <body>
    <div class="header">
      <div class="title">Live Transcript</div>
      <div class="header-controls">
        <div class="window-controls"></div>
      </div>
    </div>

    <div class="content" id="transcriptContent">
      <div class="empty-state">Waiting for speech...</div>
    </div>

    <div class="stats-bar" id="statsBar">
      <div class="stat-item">
        <span id="totalEntries">0 entries</span>
      </div>
      <div class="stat-item">
        <span id="totalWords">0 words</span>
      </div>
      <div class="stat-item">
        <span id="sessionTime">0:00</span>
      </div>
    </div>

    <div class="copy-feedback" id="copyFeedback">Copied to clipboard!</div>
    <div class="minimize-notification" id="minimizeNotification">
      Minimized to Control Center
    </div>

    <script>
      if (typeof $DebugTestMode === "undefined") {
        $DebugTestMode = false;
      }

      // Enhanced transcript window manager with working drag-to-unmaximize
      class TranscriptWindowManager {
        constructor() {
          this.isMaximized = false;
          this.isMinimized = false;
          this.platform = this.detectPlatform();
          this.sessionStartTime = Date.now();
          this.totalEntries = 0;
          this.totalWords = 0;
          this.fadeTimer = null;
          this.inactivityTimer = null;
          this.isWindowFocused = true;
          this.heartbeatInterval = null;
          this.maximizeToggling = false;

          // FIXED: Better drag tracking variables
          this.isDragging = false;
          this.dragStartX = 0;
          this.dragStartY = 0;
          this.dragThreshold = 8; // Reduced threshold for more responsive detection
          this.hasMovedEnoughToUnmaximize = false;
          this.dragStarted = false;

          this.init();
        }

        detectPlatform() {
          const userAgent = navigator.userAgent.toLowerCase();
          if (userAgent.includes("win")) return "windows";
          if (userAgent.includes("mac")) return "mac";
          return "other";
        }

        init() {
          if ($DebugTestMode) {
            console.log("TranscriptWindowManager: Starting initialization...");
          }
          this.setupPlatformSpecificStyles();
          this.setupEventListeners();
          this.restoreWindowState();
          this.startStatsTimer();
          this.setupFocusDetection();
          this.setupTransparencyControl();
          this.setupCommunication();
          this.startHeartbeat();
          if ($DebugTestMode) {
            console.log(
              "TranscriptWindowManager: Initialization complete, isMinimized:",
              this.isMinimized
            );
          }

          setTimeout(() => {
            this.setupDragFunctionality();
          }, 200);
        }

        startHeartbeat() {
          // Send heartbeat every 2 seconds to let control window know we're visible
          this.heartbeatInterval = setInterval(() => {
            if (!this.isMinimized && document.body.style.display !== "none") {
              localStorage.setItem(
                "transcript_heartbeat",
                Date.now().toString()
              );
            }
          }, 2000);

          // Send initial heartbeat immediately
          localStorage.setItem("transcript_heartbeat", Date.now().toString());

          // Also send a "transcript visible" message
          this.notifyControlCenter("TRANSCRIPT_VISIBLE");
        }

        getTranscriptWords() {
          const transcriptContent =
            document.getElementById("transcriptContent");
          if (!transcriptContent) {
            return "";
          }

          const transcriptEntries =
            transcriptContent.querySelectorAll(".transcript-entry");
          const words = [];

          transcriptEntries.forEach((entry) => {
            const textElement = entry.querySelector(".text");
            if (textElement && textElement.textContent.trim()) {
              // Split text into individual words and add to array
              const entryWords = textElement.textContent.trim().split(/\s+/);
              words.push(...entryWords);
            }
          });

          // Join all words with spaces to create a single string
          return words.join(" ");
        }

        setupCommunication() {
          if ($DebugTestMode) {
            console.log("üí¨ TRANSCRIPT: Setting up communication listeners...");
          }
          /*
          // Listen for custom restore event
          window.addEventListener("restoreTranscript", (event) => {
            if ($DebugTestMode) {
              console.log(
                "üí¨ TRANSCRIPT: üéØ restoreTranscript custom event received:",
                event.detail
              );
            }
            this.restoreFromMinimized();
          });

          // Listen for restore messages from control
          window.addEventListener("message", (event) => {
            if (event.data && event.data.type === "RESTORE_TRANSCRIPT") {
              if ($DebugTestMode) {
                console.log(
                  "üí¨ TRANSCRIPT: üéØ RESTORE_TRANSCRIPT message received:",
                  event.data
                );
              }
              this.restoreFromMinimized();
            }
          });

          // Check for restore flag periodically with enhanced logging
          setInterval(() => {
            const restoreFlag = localStorage.getItem(
              "transcript_restore_request"
            );
            const currentTime = Date.now();

            if (restoreFlag) {
              try {
                const parsedFlag = JSON.parse(restoreFlag);
                const messageAge = currentTime - parsedFlag.timestamp;

                if ($DebugTestMode) {
                  console.log(
                    "üí¨ TRANSCRIPT: üîî Found restore request in localStorage:"
                  );
                  console.log("  - Message:", parsedFlag);
                  console.log("  - Age:", messageAge, "ms");
                  console.log("  - From source:", parsedFlag.source);
                }

                // Only process recent messages (within 10 seconds)
                if (messageAge < 10000) {
                  if ($DebugTestMode) {
                    console.log(
                      "üí¨ TRANSCRIPT: üîî Processing restore request..."
                    );
                  }
                  localStorage.removeItem("transcript_restore_request");
                  this.restoreFromMinimized();
                } else {
                  if ($DebugTestMode) {
                    console.log(
                      "üí¨ TRANSCRIPT: üîî Restore request too old, ignoring and cleaning up"
                    );
                  }
                  localStorage.removeItem("transcript_restore_request");
                }
              } catch (e) {
                if ($DebugTestMode) {
                  console.log(
                    "üí¨ TRANSCRIPT: üîî Non-JSON restore flag found:",
                    restoreFlag
                  );
                }
                localStorage.removeItem("transcript_restore_request");
                this.restoreFromMinimized();
              }
            }
          }, 500); // Check every 500ms for faster response
*/
          if ($DebugTestMode) {
            console.log("üí¨ TRANSCRIPT: ‚úÖ Communication setup complete");
          }
        }
        setupPlatformSpecificStyles() {
          // Detect platform
          this.platform = navigator.platform.toLowerCase().includes("mac")
            ? "mac"
            : "windows";

          if ($DebugTestMode) {
            console.log("Detected platform:", this.platform);
            console.log("navigator.platform:", navigator.platform);
          }

          // Add platform class to body
          document.body.classList.add(`platform-${this.platform}`);
          if ($DebugTestMode) {
            console.log("Added class to body:", `platform-${this.platform}`);
            console.log("Body classes:", document.body.classList.toString());
          }

          const windowControls = document.querySelector(".window-controls");
          if ($DebugTestMode) {
            console.log("Found windowControls element:", windowControls);
          }

          if (windowControls) {
            // Clear the container
            windowControls.innerHTML = "";
            if ($DebugTestMode) {
              console.log("Cleared windowControls innerHTML");
            }

            // Add platform-mac class to windowControls if platform is Mac
            if (this.platform === "mac") {
              windowControls.classList.add("platform-mac");
              if ($DebugTestMode) {
                console.log("Added platform-mac class to windowControls");
              }
            } else {
              windowControls.classList.remove("platform-mac");
              if ($DebugTestMode) {
                console.log("Removed platform-mac class from windowControls");
              }
            }

            // Create window control buttons with platform-specific maximize button content
            const maximizeButtonContent =
              this.platform === "mac"
                ? "" // Empty for Mac (styled via CSS)
                : "&#9634;"; // Square symbol for Windows

            windowControls.innerHTML = `
          <button class="window-control-btn minimize-btn" id="minimizeBtn" title="Minimize to Control Center"></button>
          <button class="window-control-btn maximize-btn" id="maximizeBtn" title="Maximize">${maximizeButtonContent}</button>
          <button class="window-control-btn close-btn" id="closeBtn" title="Close"></button>
        `;

            if ($DebugTestMode) {
              console.log("Set window controls innerHTML");
              console.log("Maximize button content:", maximizeButtonContent);
              console.log(
                "windowControls innerHTML after setting:",
                windowControls.innerHTML
              );
              console.log(
                "windowControls classes:",
                windowControls.classList.toString()
              );
              console.log(
                "Window controls created, event listeners will be attached in setupEventListeners()"
              );
            }
          } else {
            if ($DebugTestMode) {
              console.error(
                "windowControls element not found! Make sure .window-controls exists in your HTML"
              );
            }
          }
        }

        setupFocusDetection() {
          window.addEventListener("focus", () => {
            this.isWindowFocused = true;
            document.body.classList.remove("inactive");
          });

          window.addEventListener("blur", () => {
            this.isWindowFocused = false;
            setTimeout(() => {
              if (!this.isWindowFocused && !this.isMaximized) {
                document.body.classList.add("inactive");
              }
            }, 1000);
          });

          document.addEventListener("visibilitychange", () => {
            if (document.hidden) {
              this.isWindowFocused = false;
              // Don't add inactive class if maximized
              if (!this.isMaximized) {
                document.body.classList.add("inactive");
              }
            } else {
              this.isWindowFocused = true;
              document.body.classList.remove("inactive");
              if (!this.heartbeatInterval && !this.isMinimized) {
                this.startHeartbeat();
              }
            }
          });
        }

        setupTransparencyControl() {
          document.body.classList.add("fade-mode");
          this.startInactivityTimer();
        }

        startInactivityTimer() {
          if ($DebugTestMode) {
            console.log("resetInactivityTimer() CALLED NUMBER 1");
          }
          this.resetInactivityTimer();
        }

        resetInactivityTimer() {
          if ($DebugTestMode) {
            console.log("[Activity] resetInactivityTimer() called");
          }

          // Clear existing timer if present
          if (this.inactivityTimer) {
            if ($DebugTestMode) {
              console.log("[Timer] Clearing existing inactivity timer");
            }
            clearTimeout(this.inactivityTimer);
          } else {
            if ($DebugTestMode) {
              console.log("[Timer] No existing timer to clear");
            }
          }

          // Always remove 'inactive' class when activity is detected
          if (document.body.classList.contains("inactive")) {
            if ($DebugTestMode) {
              console.log(
                "[UI] Removing 'inactive' class (making window darker)"
              );
            }
            document.body.classList.remove("inactive");
          } else {
            if ($DebugTestMode) {
              console.log("[UI] 'inactive' class not present (already darker)");
            }
          }

          // Set new timer
          if ($DebugTestMode) {
            console.log("[Timer] Setting new 5-second inactivity timer");
          }
          this.inactivityTimer = setTimeout(() => {
            if ($DebugTestMode) {
              console.log(
                "[Timer] Inactivity timeout reached (5 seconds without activity)"
              );
            }

            // Don't add inactive class if window is maximized (fullscreen)
            if (!this.isWindowFocused && !this.isMaximized) {
              if ($DebugTestMode) {
                console.log(
                  "[UI] Adding 'inactive' class (making window more transparent)"
                );
              }
              document.body.classList.add("inactive");
            } else {
              if ($DebugTestMode) {
                console.log(
                  "[UI] Window is focused or maximized - not adding 'inactive' class"
                );
              }
            }
          }, 5000);
        }

        // COMPLETELY REWRITTEN: Simplified and fixed drag functionality
        setupDragFunctionality() {
          const header = document.querySelector(".header");

          if ($DebugTestMode) {
            console.log("üéØ Setting up drag functionality on header:", header);
            console.log("üéØ Header exists:", !!header);
            console.log("üéØ Current time:", new Date().toISOString());
          }

          // ADD: Safety check
          if (!header) {
            if ($DebugTestMode) {
              console.error(
                "‚ùå Header element not found! Cannot setup drag functionality."
              );
            }
            return;
          }

          // Mouse events for desktop
          header.addEventListener(
            "mousedown",
            (e) => {
              if ($DebugTestMode) {
                console.log("üñ±Ô∏è MOUSEDOWN event fired on header");
              }
              this.handleDragStart(e, e.clientX, e.clientY);
            },
            { passive: false }
          );

          document.addEventListener(
            "mousemove",
            (e) => {
              this.handleDragMove(e, e.clientX, e.clientY);
            },
            { passive: false }
          );

          document.addEventListener(
            "mouseup",
            (e) => {
              if ($DebugTestMode) {
                console.log("üñ±Ô∏è MOUSEUP event fired");
              }
              this.handleDragEnd(e);
            },
            { passive: false }
          );

          // Touch events for mobile/tablet
          header.addEventListener("touchstart", (e) => {
            if (e.touches.length === 1) {
              const touch = e.touches[0];
              this.handleDragStart(e, touch.clientX, touch.clientY);
            }
          });

          document.addEventListener("touchmove", (e) => {
            if (e.touches.length === 1 && this.isDragging) {
              const touch = e.touches[0];
              this.handleDragMove(e, touch.clientX, touch.clientY);
            }
          });

          document.addEventListener("touchend", (e) => {
            this.handleDragEnd(e);
          });

          // Handle edge cases
          document.addEventListener("mouseleave", () => {
            if (this.isDragging) {
              if ($DebugTestMode) {
                console.log("üñ±Ô∏è Mouse left window during drag - ending drag");
              }
              this.handleDragEnd();
            }
          });

          window.addEventListener("blur", () => {
            if (this.isDragging) {
              if ($DebugTestMode) {
                console.log("üñ±Ô∏è Window lost focus during drag - ending drag");
              }
              this.handleDragEnd();
            }
          });
        }

        handleDragStart(e, clientX, clientY) {
          if ($DebugTestMode) {
            console.log("üéØ handleDragStart called", {
              eventType: e.type,
              target: e.target.className || e.target.tagName,
              clientX: clientX,
              clientY: clientY,
            });
          }

          // Only start drag if clicking on draggable area (not buttons)
          if (e.target.closest(".window-control-btn")) {
            if ($DebugTestMode) {
              console.log("üö´ Drag blocked - clicked on control button");
            }
            return;
          }

          // Prevent text selection during drag
          e.preventDefault();

          this.isDragging = true;
          this.dragStarted = true;
          this.dragStartX = clientX;
          this.dragStartY = clientY;
          this.hasMovedEnoughToUnmaximize = false;

          // Add visual feedback
          const header = document.querySelector(".header");
          header.classList.add("dragging");

          if ($DebugTestMode) {
            console.log(
              "üñ±Ô∏è DRAG START - Position:",
              this.dragStartX,
              this.dragStartY,
              "- Maximized:",
              this.isMaximized
            );
          }
        }

        handleDragMove(e, clientX, clientY) {
          if (!this.isDragging || !this.dragStarted) {
            return;
          }

          // Prevent default behavior
          e.preventDefault();

          const deltaX = Math.abs(clientX - this.dragStartX);
          const deltaY = Math.abs(clientY - this.dragStartY);
          const totalMovement = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

          if ($DebugTestMode) {
            console.log(
              "üñ±Ô∏è DRAG MOVE - Delta:",
              deltaX.toFixed(1),
              deltaY.toFixed(1),
              "Total:",
              totalMovement.toFixed(1),
              "Threshold:",
              this.dragThreshold
            );
          }

          // Check if we've moved enough to trigger unmaximize
          if (
            totalMovement > this.dragThreshold &&
            !this.hasMovedEnoughToUnmaximize
          ) {
            this.hasMovedEnoughToUnmaximize = true;

            if (this.isMaximized) {
              if ($DebugTestMode) {
                console.log(
                  "üéØ DRAG THRESHOLD EXCEEDED while maximized - UNMAXIMIZING!"
                );
              }
              this.restoreWindow();
            }
          }

          // Original drag-to-top functionality (only if not maximized)
          if (!this.isMaximized && clientY <= 5) {
            if ($DebugTestMode) {
              console.log("üîù Dragged to top edge - maximizing window");
            }
            this.maximizeWindow();
          }
        }

        handleDragEnd(e) {
          if (!this.isDragging) {
            return;
          }

          if ($DebugTestMode) {
            console.log("üñ±Ô∏è DRAG END");
          }

          this.isDragging = false;
          this.dragStarted = false;
          this.hasMovedEnoughToUnmaximize = false;

          // Remove visual feedback
          const header = document.querySelector(".header");
          header.classList.remove("dragging");

          if (e) {
            e.preventDefault();
          }
        }

        setupEventListeners() {
          if ($DebugTestMode) {
            console.log("Setting up event listeners...");
          }

          const minimizeBtn = document.getElementById("minimizeBtn");
          const maximizeBtn = document.getElementById("maximizeBtn");
          const closeBtn = document.getElementById("closeBtn");

          if ($DebugTestMode) {
            console.log("Found minimize button:", minimizeBtn);
            console.log("Found maximize button:", maximizeBtn);
            console.log("Found close button:", closeBtn);
          }

          if (minimizeBtn) {
            if ($DebugTestMode) {
              console.log("Adding click listener to minimize button");
            }
            minimizeBtn.addEventListener("click", (e) => {
              if ($DebugTestMode) {
                console.log("Minimize button clicked!");
              }
              e.preventDefault();
              e.stopPropagation();
              this.minimizeToControl();
            });
          } else {
            if ($DebugTestMode) {
              console.error("Minimize button not found!");
            }
          }

          if (maximizeBtn) {
            if ($DebugTestMode) {
              console.log("Adding click listener to maximize button");
            }
            maximizeBtn.addEventListener("click", (e) => {
              if ($DebugTestMode) {
                console.log("Maximize button clicked!");
              }
              e.preventDefault();
              e.stopPropagation();
              this.toggleMaximize();
            });
          } else {
            if ($DebugTestMode) {
              console.error("Maximize button not found!");
            }
          }

          if (closeBtn) {
            if ($DebugTestMode) {
              console.log("Adding click listener to close button");
            }
            closeBtn.addEventListener("click", (e) => {
              if ($DebugTestMode) {
                console.log("Close button clicked!");
              }
              e.preventDefault();
              e.stopPropagation();
              this.minimizeToControl(); // CHANGED: Now calls minimizeToControl() instead of closeWindow()
            });
          } else {
            if ($DebugTestMode) {
              console.error("Close button not found!");
            }
          }

          window.addEventListener("resize", () => this.handleResize());
          window.addEventListener("beforeunload", () => this.saveWindowState());

          this.setupCopyFunctionality();

          document.addEventListener("mousemove", () => {
            if ($DebugTestMode) {
              console.log("resetInactivityTimer() CALLED NUMBER 2");
            }
            this.resetInactivityTimer();
          });

          document.addEventListener("click", () => {
            if ($DebugTestMode) {
              console.log("resetInactivityTimer() CALLED NUMBER 3");
            }
            this.resetInactivityTimer();
          });

          document.addEventListener("keydown", () => {
            if ($DebugTestMode) {
              console.log("resetInactivityTimer() CALLED NUMBER 4");
            }
            this.resetInactivityTimer();
          });

          // Emergency restore shortcut (Ctrl+Shift+T)
          document.addEventListener("keydown", (e) => {
            if (e.ctrlKey && e.shiftKey && e.code === "KeyT") {
              if ($DebugTestMode) {
                console.log("Emergency restore triggered");
              }
              document.body.style.display = "block";
              this.isMinimized = false;
              sessionStorage.removeItem("transcript_minimized_this_session");
              localStorage.removeItem("transcript_minimized");
              if (!this.heartbeatInterval) {
                this.startHeartbeat();
              }
              window.focus();
            }
          });

          if ($DebugTestMode) {
            console.log("Event listeners setup complete");
          }
        }

        minimizeToControl() {
          if ($DebugTestMode) {
            console.log("minimizeToControl() called");
          }

          if (this.heartbeatInterval) {
            clearInterval(this.heartbeatInterval);
            this.heartbeatInterval = null;
          }

          localStorage.removeItem("transcript_heartbeat");
          this.showMinimizeNotification();
          document.body.classList.add("minimizing");
          this.notifyControlCenter("TRANSCRIPT_MINIMIZING");

          if ($DebugTestMode) {
            console.log("Starting minimize animation...");
          }

          setTimeout(() => {
            if ($DebugTestMode) {
              console.log("Hiding window after animation");
            }
            document.body.style.display = "none";
            document.body.classList.remove("minimizing");
            this.isMinimized = true;

            sessionStorage.setItem("transcript_minimized_this_session", "true");
            localStorage.setItem("transcript_minimized", "true");
            localStorage.setItem("control_transcript_minimized", "true"); // ‚úÖ FIX: Add this line

            this.notifyControlCenter("TRANSCRIPT_MINIMIZED");

            this.notifyControlCenter("TRANSCRIPT_MINIMIZED");
          }, 400); // Match animation duration
        }

        restoreFromMinimized() {
          if ($DebugTestMode) {
            console.log(
              "üí¨ ========== TRANSCRIPT RESTORE FROM MINIMIZED DEBUG START =========="
            );
            console.log(
              "üí¨ TRANSCRIPT: restoreFromMinimized() called at:",
              new Date().toISOString()
            );
            console.log(
              "üí¨ TRANSCRIPT: Current isMinimized state:",
              this.isMinimized
            );
            console.log(
              "üí¨ TRANSCRIPT: Current body display:",
              document.body.style.display
            );
            console.log(
              "üí¨ TRANSCRIPT: Current body classes:",
              Array.from(document.body.classList)
            );
            console.log(
              "üí¨ TRANSCRIPT: Current localStorage flags before restore:"
            );
            console.log(
              "  - control_transcript_minimized:",
              localStorage.getItem("control_transcript_minimized")
            );
            console.log(
              "  - transcript_minimized:",
              localStorage.getItem("transcript_minimized")
            );
            console.log(
              "  - transcript_heartbeat:",
              localStorage.getItem("transcript_heartbeat")
            );
            console.log("üí¨ TRANSCRIPT: Current sessionStorage flags:");
            console.log(
              "  - transcript_minimized_this_session:",
              sessionStorage.getItem("transcript_minimized_this_session")
            );
            console.log(
              "üí¨ TRANSCRIPT: Heartbeat interval status:",
              !!this.heartbeatInterval
            );
          }

          // üîß FIX: Check actual window visibility, not just internal state
          const isActuallyHidden = document.body.style.display === "none";
          const shouldRestore = this.isMinimized || isActuallyHidden;

          if ($DebugTestMode) {
            console.log("üí¨ TRANSCRIPT: State analysis:");
            console.log("  - isMinimized (internal flag):", this.isMinimized);
            console.log("  - isActuallyHidden (DOM check):", isActuallyHidden);
            console.log("  - shouldRestore (decision):", shouldRestore);
          }

          if (!shouldRestore) {
            if ($DebugTestMode) {
              console.log(
                "üí¨ TRANSCRIPT: ‚ö†Ô∏è Window appears to be already visible"
              );
              console.log(
                "üí¨ TRANSCRIPT: Internal state says not minimized AND body is visible"
              );
              console.log(
                "üí¨ TRANSCRIPT: This might be a false positive - exiting early"
              );
            }
            return;
          }

          if ($DebugTestMode) {
            console.log("üí¨ TRANSCRIPT: ‚úÖ Proceeding with restore...");
            if (isActuallyHidden && !this.isMinimized) {
              console.log(
                "üí¨ TRANSCRIPT: üîß FIXING STATE DESYNC: Window is hidden but state says visible"
              );
              console.log(
                "üí¨ TRANSCRIPT: This was the bug - correcting internal state..."
              );
            }
          }

          // üîß FIX: Correct internal state if it's wrong
          if (isActuallyHidden && !this.isMinimized) {
            if ($DebugTestMode) {
              console.log(
                "üí¨ TRANSCRIPT: üîß Correcting desynchronized state..."
              );
            }
            this.isMinimized = true; // Fix the state before proceeding
          }

          if ($DebugTestMode) {
            console.log("üí¨ TRANSCRIPT: Setting body display to 'block'...");
          }

          // Show window and start restore animation
          document.body.style.display = "block";

          if ($DebugTestMode) {
            console.log(
              "üí¨ TRANSCRIPT: Body display after setting:",
              document.body.style.display
            );
            console.log("üí¨ TRANSCRIPT: Adding 'restoring' class...");
          }

          document.body.classList.add("restoring");

          if ($DebugTestMode) {
            console.log(
              "üí¨ TRANSCRIPT: Body classes after adding 'restoring':",
              Array.from(document.body.classList)
            );
            console.log("üí¨ TRANSCRIPT: Setting isMinimized to FALSE...");
          }

          const previousMinimizedState = this.isMinimized;
          this.isMinimized = false;

          if ($DebugTestMode) {
            console.log(
              "üí¨ TRANSCRIPT: isMinimized state change:",
              previousMinimizedState,
              "‚Üí",
              this.isMinimized
            );
            console.log(
              "üí¨ TRANSCRIPT: Clearing minimized flags from storage..."
            );
          }

          // Clear minimized state from both session and local storage
          console.log(
            "‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è ALERT: CONTROL_TRANSCRIPT_MINIMIZED HAS BEEN RESET!"
          );

          const flagsBefore = {
            session: sessionStorage.getItem(
              "transcript_minimized_this_session"
            ),
            local: localStorage.getItem("transcript_minimized"),
            control: localStorage.getItem("control_transcript_minimized"),
          };

          sessionStorage.removeItem("transcript_minimized_this_session");
          localStorage.removeItem("transcript_minimized");
          localStorage.removeItem("control_transcript_minimized");

          const flagsAfter = {
            session: sessionStorage.getItem(
              "transcript_minimized_this_session"
            ),
            local: localStorage.getItem("transcript_minimized"),
            control: localStorage.getItem("control_transcript_minimized"),
          };

          if ($DebugTestMode) {
            console.log(
              "üí¨ TRANSCRIPT: Storage flags before clearing:",
              flagsBefore
            );
            console.log(
              "üí¨ TRANSCRIPT: Storage flags after clearing:",
              flagsAfter
            );
            console.log("üí¨ TRANSCRIPT: Restarting heartbeat...");
          }

          // Restart heartbeat
          if (this.heartbeatInterval) {
            if ($DebugTestMode) {
              console.log(
                "üí¨ TRANSCRIPT: Clearing existing heartbeat interval..."
              );
            }
            clearInterval(this.heartbeatInterval);
          }
          this.startHeartbeat();

          if ($DebugTestMode) {
            console.log(
              "üí¨ TRANSCRIPT: Heartbeat restarted, interval exists:",
              !!this.heartbeatInterval
            );
            console.log(
              "üí¨ TRANSCRIPT: Notifying control center of TRANSCRIPT_RESTORING..."
            );
          }

          // Notify control center that transcript is being restored
          this.notifyControlCenter("TRANSCRIPT_RESTORING");

          if ($DebugTestMode) {
            console.log("üí¨ TRANSCRIPT: Starting restore animation (400ms)...");
            console.log(
              "üí¨ TRANSCRIPT: Window should now be visible and animating"
            );
          }

          // After animation completes, remove animation class
          setTimeout(() => {
            if ($DebugTestMode) {
              console.log(
                "üí¨ TRANSCRIPT: Animation timeout reached - completing restore..."
              );
              console.log("üí¨ TRANSCRIPT: Removing 'restoring' class...");
            }

            document.body.classList.remove("restoring");

            if ($DebugTestMode) {
              console.log(
                "üí¨ TRANSCRIPT: Body classes after removing 'restoring':",
                Array.from(document.body.classList)
              );
              console.log("üí¨ TRANSCRIPT: Focusing window...");
            }

            // Focus the window
            window.focus();

            if ($DebugTestMode) {
              console.log(
                "üí¨ TRANSCRIPT: Notifying control center of TRANSCRIPT_RESTORED..."
              );
            }

            // Notify control center that restore is complete
            this.notifyControlCenter("TRANSCRIPT_RESTORED");

            if ($DebugTestMode) {
              console.log("üí¨ TRANSCRIPT: ‚úÖ Restore animation complete");
              console.log("üí¨ TRANSCRIPT: Final state check:");
              console.log("  - isMinimized:", this.isMinimized);
              console.log("  - body display:", document.body.style.display);
              console.log(
                "  - body classes:",
                Array.from(document.body.classList)
              );
              console.log("  - heartbeat active:", !!this.heartbeatInterval);
              console.log("  - window focused:", document.hasFocus());
              console.log(
                "üí¨ ========== TRANSCRIPT RESTORE FROM MINIMIZED DEBUG END =========="
              );
            }
          }, 400); // Match animation duration
        }
        notifyControlCenter(messageType) {
          // Set simple flags based on message type
          switch (messageType) {
            case "TRANSCRIPT_MINIMIZING":
            case "TRANSCRIPT_MINIMIZED":
              localStorage.setItem("transcript_minimized", "true");
              localStorage.setItem("control_transcript_minimized", "true");
              break;
            case "TRANSCRIPT_RESTORING":
            case "TRANSCRIPT_RESTORED":
              localStorage.removeItem("transcript_minimized");
              localStorage.removeItem("control_transcript_minimized");
              localStorage.setItem(
                "transcript_heartbeat",
                Date.now().toString()
              );
              break;
          }
        }
        showMinimizeNotification() {
          const notification = document.getElementById("minimizeNotification");
          if (notification) {
            notification.classList.add("show");
            setTimeout(() => {
              notification.classList.remove("show");
            }, 1500);
          }
        }

        setupCopyFunctionality() {
          const content = document.getElementById("transcriptContent");

          content.addEventListener("click", (e) => {
            const entry = e.target.closest(".transcript-entry");
            if (entry) {
              this.copyTranscriptEntry(entry);
            }
          });
        }

        copyTranscriptEntry(entry) {
          const textElement = entry.querySelector(".text");
          if (textElement) {
            const text = textElement.textContent;

            entry.classList.add("copying");

            navigator.clipboard
              .writeText(text)
              .then(() => {
                this.showCopyFeedback();
              })
              .catch((err) => {
                console.error("Failed to copy:", err);
              });

            setTimeout(() => {
              entry.classList.remove("copying");
            }, 300);
          }
        }

        showCopyFeedback() {
          const feedback = document.getElementById("copyFeedback");
          if (feedback) {
            feedback.classList.add("show");
            setTimeout(() => {
              feedback.classList.remove("show");
            }, 1500);
          }
        }

        toggleMaximize() {
          // Prevent rapid toggle calls
          if (this.maximizeToggling) {
            if ($DebugTestMode) {
              console.log(
                "üîº Transcript toggle maximize already in progress, ignoring"
              );
            }
            return;
          }

          this.maximizeToggling = true;

          if ($DebugTestMode) {
            console.log(
              "üîº Transcript toggle maximize - current state before toggle:",
              this.isMaximized
            );
          }

          // Store the intended action
          const shouldMaximize = !this.isMaximized;

          if (shouldMaximize) {
            if ($DebugTestMode) {
              console.log("üîº Transcript executing MAXIMIZE");
            }
            this.maximizeWindow();
          } else {
            if ($DebugTestMode) {
              console.log("üîº Transcript executing RESTORE");
            }
            this.restoreWindow();
          }

          // FIXED: Extended delay to ensure Electron APIs complete
          setTimeout(() => {
            // Force button update after state change
            this.updateMaximizeButton();
            if ($DebugTestMode) {
              console.log(
                "üîº Transcript final state after toggle:",
                this.isMaximized
              );
              console.log("üîº Transcript forced button update after toggle");
            }
          }, 150);

          // Clear the toggle lock after a longer delay to prevent resize interference
          setTimeout(() => {
            this.maximizeToggling = false;
            if ($DebugTestMode) {
              console.log("üîº Transcript toggle lock cleared");
            }
          }, 500); // Increased to 500ms
        }

        maximizeWindow() {
          if ($DebugTestMode) {
            console.log(
              "üîº Transcript maximizing window - setting state to TRUE"
            );
          }

          // FIXED: Set state BEFORE calling Electron API to prevent race conditions
          this.isMaximized = true;
          document.body.classList.add("maximized");

          // FIXED: Remove inactive class when maximizing
          document.body.classList.remove("inactive");

          // Update button immediately with new state
          this.updateMaximizeButton();

          // FIXED: Use proper Electron API calls AFTER setting internal state
          if (window.electronAPI && window.electronAPI.maximizeWindow) {
            if ($DebugTestMode) {
              console.log("Calling electronAPI.maximizeWindow()");
            }
            window.electronAPI.maximizeWindow();
          } else {
            if ($DebugTestMode) {
              console.log(
                "electronAPI.maximizeWindow not available, using fallback"
              );
            }
            // Fallback for web browsers
            if (document.documentElement.requestFullscreen) {
              document.documentElement.requestFullscreen();
            }
          }

          if ($DebugTestMode) {
            console.log(
              "‚úÖ Transcript window maximized, state set to:",
              this.isMaximized
            );
          }
        }

        restoreWindow() {
          if ($DebugTestMode) {
            console.log(
              "üîΩ Transcript restoring window - setting state to FALSE"
            );
          }

          // FIXED: Set state BEFORE calling Electron API to prevent race conditions
          this.isMaximized = false;
          document.body.classList.remove("maximized");

          // Update button immediately with new state
          this.updateMaximizeButton();

          // FIXED: Use proper Electron API calls AFTER setting internal state
          if (window.electronAPI && window.electronAPI.restoreWindow) {
            if ($DebugTestMode) {
              console.log("Calling electronAPI.restoreWindow()");
            }
            window.electronAPI.restoreWindow();
          } else {
            if ($DebugTestMode) {
              console.log(
                "electronAPI.restoreWindow not available, using fallback"
              );
            }
            // Fallback for web browsers
            if (document.exitFullscreen) {
              document.exitFullscreen();
            }
          }

          // Reset inactivity timer when restoring from maximized state
          this.resetInactivityTimer();

          if ($DebugTestMode) {
            console.log(
              "‚úÖ Transcript window restored, state set to:",
              this.isMaximized
            );
          }
        }

        updateMaximizeButton() {
          const maximizeBtn = document.getElementById("maximizeBtn");
          if (maximizeBtn) {
            const newTitle = this.isMaximized ? "Restore" : "Maximize";

            // Update title
            maximizeBtn.title = newTitle;

            // FIXED: Update CSS classes for styling
            if (this.isMaximized) {
              maximizeBtn.classList.add("maximized");
            } else {
              maximizeBtn.classList.remove("maximized");
            }

            // ADDED: Force icon update using innerHTML (same as AI window)
            const newIcon = this.getMaximizeIcon();
            maximizeBtn.innerHTML = newIcon;

            if ($DebugTestMode) {
              console.log(
                `üîò Updated transcript maximize button: ${newTitle} (${newIcon}) - isMaximized: ${this.isMaximized}`
              );
              console.log(`üîò Button element:`, maximizeBtn);
              console.log(
                `üîò Button innerHTML after update:`,
                maximizeBtn.innerHTML
              );
            }

            // Force a visual refresh
            maximizeBtn.offsetHeight; // Trigger reflow
          } else {
            if ($DebugTestMode) {
              console.error(
                "‚ùå Transcript maximize button not found! Cannot update icon."
              );
            }
          }
        }

        getMaximizeIcon() {
          if (this.platform === "windows") {
            return this.isMaximized ? "üóó" : "&#9634;";
          } else if (this.platform === "mac") {
            // Mac uses different symbols
            return this.isMaximized ? "‚Üô" : "‚Üó";
          } else {
            // Default to Windows icons
            return this.isMaximized ? "üóó" : "&#9634;";
          }
        }

        closeWindow() {
          if ($DebugTestMode) {
            console.log("closeWindow() called");
          }

          if (this.heartbeatInterval) {
            clearInterval(this.heartbeatInterval);
            this.heartbeatInterval = null;
          }
          localStorage.removeItem("transcript_heartbeat");

          if (window.electronAPI && window.electronAPI.closeWindow) {
            if ($DebugTestMode) {
              console.log("Calling electronAPI.closeWindow()");
            }
            window.electronAPI.closeWindow();
          } else {
            if ($DebugTestMode) {
              console.log(
                "electronAPI.closeWindow not available, using fallback"
              );
            }
            // Fallback for web browsers
            window.close();
          }
        }

        // REPLACE the existing handleResize() function with this enhanced version:
        handleResize() {
          // Don't interfere if we're in the middle of a manual toggle
          if (this.maximizeToggling) {
            if ($DebugTestMode) {
              console.log(
                "üîç Transcript resize detected but toggle in progress, ignoring"
              );
            }
            return;
          }

          const isFullscreen =
            window.innerWidth === screen.width &&
            window.innerHeight === screen.height;

          // Only update if there's a significant change and we're not manually toggling
          if (isFullscreen !== this.isMaximized) {
            if ($DebugTestMode) {
              console.log(
                `üîç Transcript resize state change detected: ${this.isMaximized} ‚Üí ${isFullscreen}`
              );
            }

            this.isMaximized = isFullscreen;

            if (isFullscreen) {
              document.body.classList.add("maximized");
            } else {
              document.body.classList.remove("maximized");
            }

            // Only update button if we're not in a manual toggle
            if (!this.maximizeToggling) {
              this.updateMaximizeButton();
            }
          }
        }

        startStatsTimer() {
          setInterval(() => {
            this.updateStats();
          }, 1000);
        }

        updateStats() {
          const sessionTime = Math.floor(
            (Date.now() - this.sessionStartTime) / 1000
          );
          const minutes = Math.floor(sessionTime / 60);
          const seconds = sessionTime % 60;

          document.getElementById(
            "totalEntries"
          ).textContent = `${this.totalEntries} entries`;
          document.getElementById(
            "totalWords"
          ).textContent = `${this.totalWords} words`;
          document.getElementById(
            "sessionTime"
          ).textContent = `${minutes}:${seconds.toString().padStart(2, "0")}`;
        }

        addTranscriptEntry(data) {
          this.totalEntries++;

          if (data.text) {
            this.totalWords += data.text.split(" ").length;
          }

          this.updateStats();
        }

        saveWindowState() {
          const state = {
            isMaximized: this.isMaximized,
            isMinimized: this.isMinimized,
            totalEntries: this.totalEntries,
            totalWords: this.totalWords,
            sessionStartTime: this.sessionStartTime,
            timestamp: Date.now(),
          };

          localStorage.setItem(
            "transcript_window_state",
            JSON.stringify(state)
          );
        }

        restoreWindowState() {
          try {
            const savedState = localStorage.getItem("transcript_window_state");
            if (savedState) {
              const state = JSON.parse(savedState);

              if (Date.now() - state.timestamp < 24 * 60 * 60 * 1000) {
                if (state.isMaximized) {
                  setTimeout(() => this.maximizeWindow(), 100);
                }

                if (Date.now() - state.sessionStartTime < 4 * 60 * 60 * 1000) {
                  this.totalEntries = state.totalEntries || 0;
                  this.totalWords = state.totalWords || 0;
                  this.sessionStartTime = state.sessionStartTime || Date.now();
                }
              }
            }
          } catch (error) {
            if ($DebugTestMode) {
              console.error("Failed to restore window state:", error);
            }
          }
        }
      }

      // Enhanced transcript processing
      let transcriptManager = new TranscriptWindowManager();

      function getTranscriptWords() {
        return transcriptManager.getTranscriptWords();
      }
      // Test functions for debugging (can be called from console)
      window.testMinimize = () => {
        if ($DebugTestMode) {
          console.log("Testing minimize function...");
        }
        transcriptManager.minimizeToControl();
      };

      window.testMaximize = () => {
        if ($DebugTestMode) {
          console.log("Testing maximize function...");
        }
        transcriptManager.toggleMaximize();
      };

      window.testClose = () => {
        if ($DebugTestMode) {
          console.log("Testing close function...");
        }
        transcriptManager.closeWindow();
      };

      // TEST FUNCTION: Click the maximize button to test
      window.testDragToUnmaximize = () => {
        if ($DebugTestMode) {
          console.log("üß™ Testing drag-to-unmaximize...");

          // First maximize the window
          if (!transcriptManager.isMaximized) {
            console.log("üß™ Maximizing window first...");
            transcriptManager.maximizeWindow();

            // Wait a bit then simulate drag
            setTimeout(() => {
              console.log("üß™ Now simulating drag movement...");

              const header = document.querySelector(".header");

              // Simulate mousedown
              const mouseDownEvent = new MouseEvent("mousedown", {
                clientX: 100,
                clientY: 20,
                bubbles: true,
              });
              header.dispatchEvent(mouseDownEvent);

              // Simulate mousemove with enough movement to trigger unmaximize
              setTimeout(() => {
                const mouseMoveEvent = new MouseEvent("mousemove", {
                  clientX: 150, // 50px movement
                  clientY: 60, // 40px movement
                  bubbles: true,
                });
                document.dispatchEvent(mouseMoveEvent);

                // Simulate mouseup
                setTimeout(() => {
                  const mouseUpEvent = new MouseEvent("mouseup", {
                    clientX: 150,
                    clientY: 60,
                    bubbles: true,
                  });
                  document.dispatchEvent(mouseUpEvent);

                  console.log(
                    "üß™ Drag simulation complete. Check if window unmaximized."
                  );
                }, 100);
              }, 100);
            }, 500);
          } else {
            console.log("üß™ Window already maximized, simulating drag...");
            // Same simulation code here...
          }
        }
      };

      // Set up mutation observer for new content detection
      const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          if (mutation.type === "childList" && mutation.addedNodes.length > 0) {
            if ($DebugTestMode) {
              console.log("resetInactivityTimer() CALLED NUMBER 5");
            }
            transcriptManager.resetInactivityTimer();
          }
        });
      });

      observer.observe(document.getElementById("transcriptContent"), {
        childList: true,
        subtree: true,
      });

      // Listen for new transcripts from main process
      if (window.electronAPI && window.electronAPI.onNewTranscript) {
        window.electronAPI.onNewTranscript((data) => {
          const content = document.getElementById("transcriptContent");

          const emptyState = content.querySelector(".empty-state");
          if (emptyState) emptyState.remove();

          if ($DebugTestMode) {
            console.log("resetInactivityTimer() CALLED NUMBER 6");
          }
          transcriptManager.resetInactivityTimer();

          if (data.isUpdate && data.transcriptId) {
            const existingEntry = document.querySelector(
              `[data-transcript-id="${data.transcriptId}"]`
            );
            if (existingEntry) {
              const textDiv = existingEntry.querySelector(".text");
              if (textDiv) {
                textDiv.textContent = data.text;
              }

              const wordCountDiv = existingEntry.querySelector(".word-count");
              if (wordCountDiv) {
                wordCountDiv.textContent = `${
                  data.text.split(" ").length
                } words`;
              }

              const originalDiv = existingEntry.querySelector(".original-text");
              if (data.originalText && data.originalText !== data.text) {
                if (!originalDiv) {
                  const newOriginalDiv = document.createElement("div");
                  newOriginalDiv.className = "original-text";
                  newOriginalDiv.textContent = data.originalText;
                  existingEntry.appendChild(newOriginalDiv);
                } else {
                  originalDiv.textContent = data.originalText;
                }

                if (!existingEntry.querySelector(".corrected-indicator")) {
                  const indicator = document.createElement("div");
                  indicator.className = "corrected-indicator";
                  indicator.innerHTML = "Corrected";
                  existingEntry.appendChild(indicator);
                }
              }

              if (!data.isPartial) {
                existingEntry.classList.remove("partial");
              }
            }
            return;
          }

          // Create new entry
          const entry = document.createElement("div");
          entry.className = "transcript-entry";
          if (data.isQuestion) entry.className += " question";
          if (data.isPartial) entry.className += " partial";

          if (data.transcriptId) {
            entry.setAttribute("data-transcript-id", data.transcriptId);
          }

          const timestamp = new Date().toLocaleTimeString([], {
            hour: "2-digit",
            minute: "2-digit",
            second: "2-digit",
          });

          let entryHTML = `<div class="timestamp">${timestamp}</div>`;

          if (data.originalText && data.originalText !== data.text) {
            entryHTML += `<div class="corrected-indicator">Corrected</div>`;
          }

          entryHTML += `<div class="text">${data.text}</div>`;

          const wordCount = data.text.split(" ").length;
          let metaHTML = `<div class="entry-meta">`;
          metaHTML += `<span class="word-count">${wordCount} words</span>`;

          if (data.confidence) {
            const confidenceClass =
              data.confidence > 0.8
                ? "high"
                : data.confidence > 0.6
                ? "medium"
                : "low";
            metaHTML += `<span class="confidence-score ${confidenceClass}">${Math.round(
              data.confidence * 100
            )}%</span>`;
          }

          metaHTML += `</div>`;
          entryHTML += metaHTML;

          if (data.originalText && data.originalText !== data.text) {
            entryHTML += `<div class="original-text">${data.originalText}</div>`;
          }

          entry.innerHTML = entryHTML;
          content.appendChild(entry);
          content.scrollTop = content.scrollHeight;

          transcriptManager.addTranscriptEntry(data);

          const entries = content.querySelectorAll(".transcript-entry");
          if (entries.length > 100) {
            entries[0].remove();
          }
        });
      }

      document.addEventListener("DOMContentLoaded", () => {
        if ($DebugTestMode) {
          console.log("üöÄ DOM loaded, initializing TranscriptWindowManager...");
          console.log("üöÄ Current timestamp:", new Date().toISOString());
        }

        // Initialize the transcript manager first
        transcriptManager = new TranscriptWindowManager();

        // üîß NEW: IMMEDIATE minimized state check on load
        const checkMinimizedOnLoad = () => {
          if ($DebugTestMode) {
            console.log(
              "üîç ========== ON-LOAD MINIMIZED CHECK DEBUG START =========="
            );
            console.log(
              "üîç TRANSCRIPT: Checking minimized flags immediately on load..."
            );
            console.log("üîç TRANSCRIPT: Load time:", new Date().toISOString());
            console.log(
              "üîç TRANSCRIPT: Document ready state:",
              document.readyState
            );
            console.log(
              "üîç TRANSCRIPT: Body display before check:",
              document.body.style.display
            );
          }

          const controlMinimized = localStorage.getItem(
            "control_transcript_minimized"
          );
          const transcriptMinimized = localStorage.getItem(
            "transcript_minimized"
          );
          const sessionMinimized = sessionStorage.getItem(
            "transcript_minimized_this_session"
          );
          const heartbeat = localStorage.getItem("transcript_heartbeat");
          const heartbeatAge = heartbeat
            ? Date.now() - parseInt(heartbeat)
            : null;

          if ($DebugTestMode) {
            console.log("üîç TRANSCRIPT: On-load minimized flags analysis:");
            console.log(
              "  - control_transcript_minimized:",
              controlMinimized,
              "(type:",
              typeof controlMinimized,
              ")"
            );
            console.log(
              "  - transcript_minimized:",
              transcriptMinimized,
              "(type:",
              typeof transcriptMinimized,
              ")"
            );
            console.log(
              "  - transcript_minimized_this_session:",
              sessionMinimized,
              "(type:",
              typeof sessionMinimized,
              ")"
            );
            console.log("  - transcript_heartbeat:", heartbeat);
            console.log("  - heartbeat age:", heartbeatAge, "ms");
            console.log("üîç TRANSCRIPT: Decision logic:");
            console.log(
              "  - controlMinimized === 'true':",
              controlMinimized === "true"
            );
            console.log(
              "  - transcriptMinimized === 'true':",
              transcriptMinimized === "true"
            );
            console.log(
              "  - sessionMinimized === 'true':",
              sessionMinimized === "true"
            );
          }

          // If ANY minimized flag is true, hide immediately
          const shouldHide =
            controlMinimized === "true" ||
            transcriptMinimized === "true" ||
            sessionMinimized === "true";

          if ($DebugTestMode) {
            console.log("üîç TRANSCRIPT: Should hide window:", shouldHide);
          }

          if (shouldHide) {
            if ($DebugTestMode) {
              console.log(
                "üîç TRANSCRIPT: ‚ö†Ô∏è TRANSCRIPT IS MINIMIZED - HIDING WINDOW IMMEDIATELY"
              );
              console.log("üîç TRANSCRIPT: Hiding reason breakdown:");
              if (controlMinimized === "true")
                console.log("  - control_transcript_minimized is true");
              if (transcriptMinimized === "true")
                console.log("  - transcript_minimized is true");
              if (sessionMinimized === "true")
                console.log("  - session minimized is true");
            }

            // Set internal state
            if (transcriptManager) {
              const prevState = transcriptManager.isMinimized;
              transcriptManager.isMinimized = true;
              if ($DebugTestMode) {
                console.log(
                  "üîç TRANSCRIPT: Manager state change - isMinimized:",
                  prevState,
                  "‚Üí",
                  transcriptManager.isMinimized
                );
              }
            }

            // Hide the window immediately
            const prevDisplay = document.body.style.display;
            document.body.style.display = "none";

            if ($DebugTestMode) {
              console.log(
                "üîç TRANSCRIPT: Body display change:",
                prevDisplay,
                "‚Üí",
                document.body.style.display
              );
            }

            // Stop heartbeat since we're minimized
            if (transcriptManager && transcriptManager.heartbeatInterval) {
              if ($DebugTestMode) {
                console.log("üîç TRANSCRIPT: Stopping heartbeat interval...");
              }
              clearInterval(transcriptManager.heartbeatInterval);
              transcriptManager.heartbeatInterval = null;
            }

            // Remove heartbeat from localStorage
            const prevHeartbeat = localStorage.getItem("transcript_heartbeat");
            localStorage.removeItem("transcript_heartbeat");

            if ($DebugTestMode) {
              console.log(
                "üîç TRANSCRIPT: Heartbeat removed:",
                prevHeartbeat,
                "‚Üí",
                localStorage.getItem("transcript_heartbeat")
              );
              console.log(
                "üîç TRANSCRIPT: ‚úÖ Transcript window hidden on load due to minimized state"
              );
              console.log("üîç TRANSCRIPT: Final state verification:");
              console.log("  - Body display:", document.body.style.display);
              console.log(
                "  - Manager isMinimized:",
                transcriptManager?.isMinimized
              );
              console.log(
                "  - Heartbeat stopped:",
                !transcriptManager?.heartbeatInterval
              );
              console.log(
                "üîç ========== ON-LOAD MINIMIZED CHECK DEBUG END (HIDDEN) =========="
              );
            }

            return true; // Indicates window was hidden
          } else {
            if ($DebugTestMode) {
              console.log(
                "üîç TRANSCRIPT: ‚úÖ Transcript is NOT minimized - keeping window visible"
              );
              console.log("üîç TRANSCRIPT: Ensuring window visibility...");
            }

            // Ensure window is visible and heartbeat is running
            const prevDisplay = document.body.style.display;
            document.body.style.display = "block";

            if (transcriptManager) {
              const prevState = transcriptManager.isMinimized;
              transcriptManager.isMinimized = false;
              if ($DebugTestMode) {
                console.log(
                  "üîç TRANSCRIPT: Manager state - isMinimized:",
                  prevState,
                  "‚Üí",
                  transcriptManager.isMinimized
                );
              }
            }

            if (!transcriptManager?.heartbeatInterval) {
              if ($DebugTestMode) {
                console.log("üîç TRANSCRIPT: Starting heartbeat...");
              }
              transcriptManager?.startHeartbeat();
            }

            if ($DebugTestMode) {
              console.log("üîç TRANSCRIPT: Final visible state verification:");
              console.log(
                "  - Body display change:",
                prevDisplay,
                "‚Üí",
                document.body.style.display
              );
              console.log(
                "  - Manager isMinimized:",
                transcriptManager?.isMinimized
              );
              console.log(
                "  - Heartbeat running:",
                !!transcriptManager?.heartbeatInterval
              );
              console.log(
                "üîç ========== ON-LOAD MINIMIZED CHECK DEBUG END (VISIBLE) =========="
              );
            }

            return false; // Indicates window is visible
          }
        };
        // Call the check immediately
        const wasHidden = checkMinimizedOnLoad();

        if ($DebugTestMode) {
          console.log("‚úÖ Enhanced transcript window initialized");
          console.log("‚úÖ Window was hidden on load:", wasHidden);
        }

        // MODIFIED: Only show fallback visibility if NOT minimized
        if (!wasHidden) {
          setTimeout(() => {
            if (
              document.body.style.display === "none" &&
              !transcriptManager.isMinimized
            ) {
              if ($DebugTestMode) {
                console.log("Fallback: Making transcript window visible");
              }
              document.body.style.display = "block";
              if (!transcriptManager.heartbeatInterval) {
                transcriptManager.startHeartbeat();
              }
            }
          }, 1000);
        }
      });

      // üîß NEW: Also add emergency restore functionality
      // Add this as a global function for debugging
      window.forceShowTranscript = () => {
        if ($DebugTestMode) {
          console.log("üö® EMERGENCY: Force showing transcript window");
        }

        // Clear all minimized flags
        localStorage.removeItem("control_transcript_minimized");
        localStorage.removeItem("transcript_minimized");
        sessionStorage.removeItem("transcript_minimized_this_session");

        // Show window
        document.body.style.display = "block";

        // Update manager state
        if (window.transcriptManager) {
          window.transcriptManager.isMinimized = false;
          if (!window.transcriptManager.heartbeatInterval) {
            window.transcriptManager.startHeartbeat();
          }
        }

        if ($DebugTestMode) {
          console.log("üö® Emergency restore complete");
        }
      };

      // üîß NEW: Add keyboard shortcut for emergency restore
      document.addEventListener("keydown", (e) => {
        // Ctrl+Shift+T to force show transcript
        if (e.ctrlKey && e.shiftKey && e.code === "KeyT") {
          e.preventDefault();
          window.forceShowTranscript();
        }
      });
    </script>
  </body>
</html>
