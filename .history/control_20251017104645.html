<!DOCTYPE html>
<html class="html">
  <head>
    <meta charset="UTF-8" />
    <title>Control Bar</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      html {
        position: relative;
        pointer-events: auto;
        /*-webkit-app-region: drag;*/
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          sans-serif;
        background: rgba(10, 10, 10, 0.9);
        backdrop-filter: blur(25px);
        -webkit-backdrop-filter: blur(25px);
        -webkit-app-region: drag;
        color: #fff;
        height: 100vh;
        width: 100vh;
        overflow: hidden;
        user-select: none;
        transition: all 0.3s ease;
        display: flex;
        opacity: 1;
        line-height: 1;
        position: relative;
        pointer-events: auto;
      }

      body.expanded {
        background: rgba(10, 10, 10, 0.95);
        backdrop-filter: blur(35px);
        -webkit-backdrop-filter: blur(35px);
        height: 80px !important;
        max-height: 80px !important;
        min-height: 80px !important;
        justify-content: center;
      }

      body.fade-mode {
        background: rgba(10, 10, 10, 0.85);
        backdrop-filter: blur(35px);
        -webkit-backdrop-filter: blur(35px);
        opacity: 1;
      }

      body.inactive-mode {
        background: rgba(10, 10, 10, 0.8);
        backdrop-filter: blur(20px);
        -webkit-backdrop-filter: blur(20px);
        opacity: 0.9;
      }

      /* üîß NEW: Listening mode overrides */
      body.listening-mode {
        opacity: 1 !important;
        visibility: visible !important;
        display: flex !important;
        background: rgba(10, 10, 10, 0.95) !important;
        backdrop-filter: blur(25px) !important;
        -webkit-backdrop-filter: blur(25px) !important;
        height: 50px !important;
        max-height: 50px !important;
        min-height: 50px !important;
      }

      /* üîß NEW: Ensure listening mode overrides inactive mode */
      body.inactive-mode.listening-mode {
        opacity: 1 !important;
        background: rgba(10, 10, 10, 0.95) !important;
      }

      .container {
        box-sizing: border-box;
        display: flex;
        align-items: center;
        padding: 0 12px;
        gap: 10px;
        position: relative;
        width: fit-content;
        width: max-content;
        height: 100%;
        justify-content: space-between;
        width: 100vw;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        pointer-events: auto;
      }

      .container_wrapper {
        height: 100vh;
        width: max-content;
        display: flex;
        align-items: center;
        -webkit-app-region: drag;
      }

      .drag {
        -webkit-app-region: drag;
      }

      .btn {
        -webkit-app-region: no-drag;
        padding: 6px 16px;
        border: none;
        border-radius: 20px;
        font-size: 12px;
        font-weight: 500;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.2s ease;
        -webkit-app-region: no-drag;
        background: rgba(255, 255, 255, 0.1);
        color: #fff;
        backdrop-filter: blur(10px);
        position: relative;
        overflow: hidden;
      }

      .btn::before {
        content: "";
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(
          90deg,
          transparent,
          rgba(255, 255, 255, 0.2),
          transparent
        );
        transition: left 0.5s;
      }

      .btn:hover::before {
        left: 100%;
      }

      .listen-btn {
        background: linear-gradient(
          135deg,
          rgba(59, 130, 246, 0.8),
          rgba(29, 78, 216, 0.8)
        );
        box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
      }

      .listen-btn:hover {
        background: linear-gradient(
          135deg,
          rgba(59, 130, 246, 1),
          rgba(29, 78, 216, 1)
        );
        transform: translateY(-1px);
        box-shadow: 0 6px 16px rgba(59, 130, 246, 0.4);
      }

      .listen-btn.active {
        background: linear-gradient(
          135deg,
          rgba(239, 68, 68, 0.8),
          rgba(220, 38, 38, 0.8)
        );
        box-shadow: 0 4px 12px rgba(239, 68, 68, 0.3);
        animation: pulse 2s infinite;
      }

      @keyframes pulse {
        0%,
        100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.05);
        }
      }

      .screenshot-btn {
        background: linear-gradient(
          135deg,
          rgba(139, 92, 246, 0.8),
          rgba(124, 58, 237, 0.8)
        );
        box-shadow: 0 4px 12px rgba(139, 92, 246, 0.3);
        font-size: 15px;
      }

      .screenshot-btn:hover {
        background: linear-gradient(
          135deg,
          rgba(139, 92, 246, 1),
          rgba(124, 58, 237, 1)
        );
        transform: translateY(-1px);
        box-shadow: 0 6px 16px rgba(139, 92, 246, 0.4);
      }

      .settings-btn {
        background: linear-gradient(
          135deg,
          rgba(75, 85, 99, 0.8),
          rgba(55, 65, 81, 0.8)
        );
        box-shadow: 0 4px 12px rgba(75, 85, 99, 0.3);
        padding: 6px 12px;
        font-size: 14px;
      }

      .settings-btn:hover {
        background: linear-gradient(
          135deg,
          rgba(75, 85, 99, 1),
          rgba(55, 65, 81, 1)
        );
        transform: translateY(-1px);
        box-shadow: 0 6px 16px rgba(75, 85, 99, 0.4);
      }

      .transcript-btn {
        background: linear-gradient(
          135deg,
          rgba(16, 185, 129, 0.8),
          rgba(5, 150, 105, 0.8)
        );
        box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
        padding: 6px 12px;
        font-size: 11px;
        display: flex;
        position: relative;
      }

      .transcript-btn:hover {
        background: linear-gradient(
          135deg,
          rgba(16, 185, 129, 1),
          rgba(5, 150, 105, 1)
        );
        transform: translateY(-1px);
        box-shadow: 0 6px 16px rgba(16, 185, 129, 0.4);
      }

      .transcript-btn.show {
        display: block;
        pointer-events: auto !important;
        -webkit-app-region: no-drag !important;
        opacity: 1;
        transform: translateX(0) scale(1);
      }

      .ai-btn {
        background: linear-gradient(
          135deg,
          rgba(168, 85, 247, 0.8),
          rgba(147, 51, 234, 0.8)
        );
        box-shadow: 0 4px 12px rgba(168, 85, 247, 0.3);
        padding: 6px 12px;
        font-size: 11px;
        display: none;
        position: relative;
      }

      .ai-btn:hover {
        background: linear-gradient(
          135deg,
          rgba(168, 85, 247, 1),
          rgba(147, 51, 234, 1)
        );
        transform: translateY(-1px);
        box-shadow: 0 6px 16px rgba(168, 85, 247, 0.4);
      }

      .ai-btn.show {
        display: block !important;
        pointer-events: auto !important;
        -webkit-app-region: no-drag !important;
        opacity: 1;
        transform: translateX(0) scale(1);
      }

      .ai-btn.receiving {
        animation: transcriptReceiving 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      }

      @keyframes transcriptReceiving {
        0% {
          transform: scale(1);
        }
        30% {
          transform: scale(0.8) translateX(-20px);
        }
        60% {
          transform: scale(1.1) translateX(10px);
        }
        100% {
          transform: scale(1) translateX(0);
        }
      }

      .transcript-btn::after,
      .ai-btn::after {
        content: "";
        position: absolute;
        top: 0px;
        right: 0px;
        width: 8px;
        height: 8px;
        background: #ef4444;
        border-radius: 50%;
        border: 2px solid rgba(10, 10, 10, 0.9);
        opacity: 0;
        transition: opacity 0.3s ease;
      }

      .transcript-btn.has-notification::after,
      .ai-btn.has-notification::after {
        opacity: 1;
        animation: notificationPulse 2s infinite;
      }

      @keyframes notificationPulse {
        0%,
        100% {
          transform: scale(1);
          opacity: 1;
        }
        50% {
          transform: scale(1.3);
          opacity: 0.7;
        }
      }

      .status {
        flex: 1;
        text-align: center;
        font-size: 11px;
        color: rgba(255, 255, 255, 0.8);
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        padding: 0 10px;
        flex-direction: column;
      }

      .status-main {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      @keyframes downloadingPulse {
        0%,
        100% {
          opacity: 1;
          transform: scale(1);
        }
        50% {
          opacity: 0.7;
          transform: scale(0.95);
        }
      }

      @keyframes installingPulse {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.6;
        }
      }

      .status-dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: #6b7280;
        transition: all 0.3s ease;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      }

      .status-dot.active {
        background: #10b981;
        animation: statusPulse 2s infinite;
        box-shadow: 0 0 12px rgba(16, 185, 129, 0.5);
      }

      .status-dot.auth {
        background: #3b82f6;
        box-shadow: 0 0 8px rgba(59, 130, 246, 0.4);
      }

      .status-dot.inactive {
        background: #6b7280;
      }

      .status-dot.error {
        background: #ef4444;
        animation: errorBlink 1s infinite;
      }

      @keyframes statusPulse {
        0%,
        100% {
          opacity: 1;
          transform: scale(1);
        }
        50% {
          opacity: 0.6;
          transform: scale(1.3);
        }
      }

      @keyframes errorBlink {
        0%,
        50% {
          opacity: 1;
        }
        51%,
        100% {
          opacity: 0.3;
        }
      }

      .close-btn {
        width: 22px;
        height: 22px;
        border-radius: 50%;
        background: linear-gradient(
          135deg,
          rgba(239, 68, 68, 0.8),
          rgba(220, 38, 38, 0.8)
        );
        border: none;
        cursor: pointer;
        display: flex;
        padding: 12px;
        align-items: center;
        justify-content: center;
        -webkit-app-region: no-drag;
        font-size: 20px;
        color: white;
        transition: all 0.2s ease;
        box-shadow: 0 2px 8px rgba(239, 68, 68, 0.3);
      }

      .close-btn:hover {
        background: linear-gradient(
          135deg,
          rgba(239, 68, 68, 1),
          rgba(220, 38, 38, 1)
        );
        transform: scale(1.1);
        box-shadow: 0 4px 12px rgba(239, 68, 68, 0.4);
      }

      .close-btn:active {
        transform: scale(0.95);
      }

      @keyframes connecting {
        0%,
        100% {
          opacity: 0.3;
        }
        50% {
          opacity: 1;
        }
      }

      .tooltip {
        position: absolute;
        bottom: 60px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.9);
        color: white;
        padding: 6px 12px;
        border-radius: 8px;
        font-size: 11px;
        white-space: nowrap;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.3s ease;
        z-index: 1000;
      }

      .tooltip.show {
        opacity: 1;
      }

      .tooltip::after {
        content: "";
        position: absolute;
        top: 100%;
        left: 50%;
        transform: translateX(-50%);
        border: 5px solid transparent;
        border-top-color: rgba(0, 0, 0, 0.9);
      }

      .shortcuts-hint {
        position: absolute;
        top: 60px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.9);
        color: white;
        padding: 8px 12px;
        border-radius: 8px;
        font-size: 10px;
        white-space: nowrap;
        opacity: 0;
        transition: opacity 0.3s ease;
        z-index: 1000;
      }

      .shortcuts-hint.show {
        opacity: 1;
      }

      @keyframes debugPulse {
        0%,
        100% {
          opacity: 0.3;
        }
        50% {
          opacity: 0.8;
        }
      }

      @media (prefers-reduced-motion: reduce) {
        * {
          animation-duration: 0.01ms !important;
          animation-iteration-count: 1 !important;
          transition-duration: 0.01ms !important;
        }
      }

      .btn:focus,
      .close-btn:focus {
        outline: 2px solid #3b82f6;
        outline-offset: 2px;
      }

      @media (prefers-contrast: high) {
        body {
          background: rgba(0, 0, 0, 0.95);
          border: 2px solid #fff;
        }

        .btn {
          background: rgba(255, 255, 255, 0.2);
          border: 1px solid rgba(255, 255, 255, 0.4);
        }

        .status-dot {
          border: 1px solid #fff;
        }
      }
    </style>
  </head>
  <body class="body">
    <div class="container_wrapper">
      <div class="container">
        <button
          class="btn listen-btn"
          id="listenBtn"
          oncontextmenu="handleRightClick(event)"
          title="Start/Stop Listening. This will start & stop the transcript."
        >
          ‚ñ∂ Listen
        </button>
        <button
          class="btn transcript-btn"
          id="transcriptBtn"
          onclick="getTranscriptWords()"
          title="Send to chat"
        >
          üí¨ Send Audio to chat
        </button>
        <button
          class="btn ai-btn"
          id="aiBtn"
          onclick="restoreAI()"
          title="Restore AI Window"
          style="display: none"
        >
          <svg
            xmlns="http://www.w3.org/2000/svg"
            viewBox="141 141 118 118"
            width="50"
            height="50"
            style="display: flex; position: relative"
          >
            <!-- Define the gradient -->
            <defs>
              <linearGradient
                id="blueGradient"
                x1="0%"
                y1="0%"
                x2="100%"
                y2="100%"
                gradientUnits="objectBoundingBox"
              >
                <stop
                  offset="0%"
                  style="stop-color: #4facfe; stop-opacity: 1"
                />
                <stop
                  offset="100%"
                  style="stop-color: #00f2fe; stop-opacity: 1"
                />
              </linearGradient>
            </defs>

            <!-- BLACK SVGs (underneath layer) -->
            <g transform="translate(200, 200)">
              <!-- First SVG: 19,151 x 19,151 with 22¬∞ rotation (largest, scaled to 95) -->
              <svg width="95" height="95" viewBox="0 0 256 256" x="-47" y="-47">
                <g transform="rotate(22 128 128)">
                  <rect width="256" height="256" fill="none" />
                  <path
                    d="M54.46,201.54c-9.2-9.2-3.1-28.53-7.78-39.85C41.82,150,24,140.5,24,128s17.82-22,22.68-33.69C51.36,83,45.26,63.66,54.46,54.46S83,51.36,94.31,46.68C106.05,41.82,115.5,24,128,24S150,41.82,161.69,46.68c11.32,4.68,30.65-1.42,39.85,7.78s3.1,28.53,7.78,39.85C214.18,106.05,232,115.5,232,128S214.18,150,209.32,161.69c-4.68,11.32,1.42,30.65-7.78,39.85s-28.53,3.1-39.85,7.78C150,214.18,140.5,232,128,232s-22-17.82-33.69-22.68C83,204.64,63.66,210.74,54.46,201.54Z"
                    fill="none"
                    stroke="white"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="8"
                  />
                </g>
              </svg>

              <!-- Second SVG: 15,135 x 15,135 with no rotation (medium, scaled to 75) -->
              <svg width="75" height="75" viewBox="0 0 256 256" x="-37" y="-37">
                <rect width="256" height="256" fill="none" />
                <path
                  d="M54.46,201.54c-9.2-9.2-3.1-28.53-7.78-39.85C41.82,150,24,140.5,24,128s17.82-22,22.68-33.69C51.36,83,45.26,63.66,54.46,54.46S83,51.36,94.31,46.68C106.05,41.82,115.5,24,128,24S150,41.82,161.69,46.68c11.32,4.68,30.65-1.42,39.85,7.78s3.1,28.53,7.78,39.85C214.18,106.05,232,115.5,232,128S214.18,150,209.32,161.69c-4.68,11.32,1.42,30.65-7.78,39.85s-28.53,3.1-39.85,7.78C150,214.18,140.5,232,128,232s-22-17.82-33.69-22.68C83,204.64,63.66,210.74,54.46,201.54Z"
                  fill="none"
                  stroke="white"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                  stroke-width="8"
                />
              </svg>

              <!-- Third SVG: 11,808 x 11,808 with 22¬∞ rotation (smallest, scaled to 59) -->
              <svg width="59" height="59" viewBox="0 0 256 256" x="-29" y="-29">
                <g transform="rotate(22 128 128)">
                  <rect width="256" height="256" fill="none" />
                  <path
                    d="M54.46,201.54c-9.2-9.2-3.1-28.53-7.78-39.85C41.82,150,24,140.5,24,128s17.82-22,22.68-33.69C51.36,83,45.26,63.66,54.46,54.46S83,51.36,94.31,46.68C106.05,41.82,115.5,24,128,24S150,41.82,161.69,46.68c11.32,4.68,30.65-1.42,39.85,7.78s3.1,28.53,7.78,39.85C214.18,106.05,232,115.5,232,128S214.18,150,209.32,161.69c-4.68,11.32,1.42,30.65-7.78,39.85s-28.53,3.1-39.85,7.78C150,214.18,140.5,232,128,232s-22-17.82-33.69-22.68C83,204.64,63.66,210.74,54.46,201.54Z"
                    fill="none"
                    stroke="white"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="8"
                  />
                </g>
              </svg>
            </g>

            <!-- COLORED SVGs (on top layer) -->
            <g transform="translate(200, 200)">
              <!-- First SVG: 19,151 x 19,151 with NO rotation (largest, scaled to 95) -->
              <svg width="95" height="95" viewBox="0 0 256 256" x="-47" y="-47">
                <rect width="256" height="256" fill="none" />
                <path
                  d="M54.46,201.54c-9.2-9.2-3.1-28.53-7.78-39.85C41.82,150,24,140.5,24,128s17.82-22,22.68-33.69C51.36,83,45.26,63.66,54.46,54.46S83,51.36,94.31,46.68C106.05,41.82,115.5,24,128,24S150,41.82,161.69,46.68c11.32,4.68,30.65-1.42,39.85,7.78s3.1,28.53,7.78,39.85C214.18,106.05,232,115.5,232,128S214.18,150,209.32,161.69c-4.68,11.32,1.42,30.65-7.78,39.85s-28.53,3.1-39.85,7.78C150,214.18,140.5,232,128,232s-22-17.82-33.69-22.68C83,204.64,63.66,210.74,54.46,201.54Z"
                  fill="none"
                  stroke="url(#blueGradient)"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                  stroke-width="8"
                />
              </svg>

              <!-- Second SVG: 15,135 x 15,135 with 22¬∞ rotation (medium, scaled to 75) -->
              <svg width="75" height="75" viewBox="0 0 256 256" x="-37" y="-37">
                <g transform="rotate(22 128 128)">
                  <rect width="256" height="256" fill="none" />
                  <path
                    d="M54.46,201.54c-9.2-9.2-3.1-28.53-7.78-39.85C41.82,150,24,140.5,24,128s17.82-22,22.68-33.69C51.36,83,45.26,63.66,54.46,54.46S83,51.36,94.31,46.68C106.05,41.82,115.5,24,128,24S150,41.82,161.69,46.68c11.32,4.68,30.65-1.42,39.85,7.78s3.1,28.53,7.78,39.85C214.18,106.05,232,115.5,232,128S214.18,150,209.32,161.69c-4.68,11.32,1.42,30.65-7.78,39.85s-28.53,3.1-39.85,7.78C150,214.18,140.5,232,128,232s-22-17.82-33.69-22.68C83,204.64,63.66,210.74,54.46,201.54Z"
                    fill="none"
                    stroke="url(#blueGradient)"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="8"
                  />
                </g>
              </svg>

              <!-- Third SVG: 11,808 x 11,808 with NO rotation (smallest, scaled to 59) -->
              <svg width="59" height="59" viewBox="0 0 256 256" x="-29" y="-29">
                <rect width="256" height="256" fill="none" />
                <path
                  d="M54.46,201.54c-9.2-9.2-3.1-28.53-7.78-39.85C41.82,150,24,140.5,24,128s17.82-22,22.68-33.69C51.36,83,45.26,63.66,54.46,54.46S83,51.36,94.31,46.68C106.05,41.82,115.5,24,128,24S150,41.82,161.69,46.68c11.32,4.68,30.65-1.42,39.85,7.78s3.1,28.53,7.78,39.85C214.18,106.05,232,115.5,232,128S214.18,150,209.32,161.69c-4.68,11.32,1.42,30.65-7.78,39.85s-28.53,3.1-39.85,7.78C150,214.18,140.5,232,128,232s-22-17.82-33.69-22.68C83,204.64,63.66,210.74,54.46,201.54Z"
                  fill="none"
                  stroke="url(#blueGradient)"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                  stroke-width="8"
                />
              </svg>
            </g>
          </svg>
          AI
        </button>
        <button
          class="btn screenshot-btn"
          onclick="captureScreenshot()"
          title="Take Screenshot. This will add the screenshot to your Micro Learner chat."
        >
          üì∏
        </button>
        <button
          class="btn settings-btn"
          onclick="openSettings()"
          title="Open Settings"
        >
          ‚öôÔ∏è
        </button>
        <!--<div class="status">
          <span class="status-dot" id="statusDot"></span>
          <span id="statusText">Ready</span>
        </div>-->
        <button
          class="close-btn"
          onclick="closeAll()"
          title="Close All Windows"
        >
          √ó
        </button>

        <div class="tooltip" id="tooltip"></div>

        <!--<div class="shortcuts-hint" id="shortcutsHint">
        Space: Toggle ‚Ä¢ T: Transcript ‚Ä¢ A: AI ‚Ä¢ Ctrl+Enter: Screenshot ‚Ä¢ S:
        Settings
      </div>-->
        <!--<div class="audio-controls" style="display: none;" id="audioControls">
  <select id="audioSourceSelect">
    <option value="mixed">System + Microphone</option>
    <option value="system">System Audio Only</option>
    <option value="microphone">Microphone Only</option>
  </select>
  <button onclick="testAudioSources()">Test Audio</button>
</div>-->
      </div>
    </div>

    <script>
      const $DebugTestMode = true;

      let isListening = false;
      window.isListening = isListening;

      // Environment detection
      const Environment = {
        isWeb: typeof window !== "undefined" && !window.electronAPI,
        isElectron: typeof window !== "undefined" && window.electronAPI,
      };

      class ControlWindowManager {
        constructor() {
          this.fadeTimer = null;
          this.transcriptMinimized = false;
          this.aiMinimized = false;
          this.aiRestoring = false;
          this.windowSizeListenerSet = false;

          // Debug enhancement properties
          this.authState = {
            isAuthenticated: false,
            user: null,
            token: null,
          };
          this.lastActivity = Date.now();
          this.keepAliveInterval = null;
          this.storageWatcher = null; // NEW: Storage monitoring

          // üîß NEW: LanguageTool status tracking
          this.languageToolReady = false;
          this.languageToolInstalled = false;

          this.init();
        }

        init() {
          if ($DebugTestMode) {
            console.log("üöÄ ControlWindowManager initializing...");
          }
          this.setupEventListeners();
          this.setupKeyboardShortcuts();
          this.setupTooltips();
          this.setupActivityDetection();
          this.setupWindowCommunication();
          this.setupKeepAlive();
          this.restoreSettings();
          this.checkAuth();
          this.setupStorageWatcher(); // NEW: Monitor localStorage changes
          this.setupLanguageToolMonitoring();

          if ($DebugTestMode) {
            console.log("üöÄ Starting window state checks...");
          }
          // üîß IMMEDIATE check for minimized states
          this.forceButtonVisibilityCheck();

          // Initial check with delay to ensure localStorage is available
          setTimeout(() => {
            if ($DebugTestMode) {
              console.log("üîç Running initial window state check...");
            }
            this.checkAllWindowStates();
          }, 100);

          // üîß ADDITIONAL aggressive check after a longer delay
          setTimeout(() => {
            if ($DebugTestMode) {
              console.log("üîß Running additional button visibility check...");
            }
            this.forceButtonVisibilityCheck();
          }, 500);

          // Set up periodic checking
          setInterval(() => {
            if ($DebugTestMode) {
              //console.log("‚è∞ Periodic window state check...");
            }
            this.checkAllWindowStates();
          }, 1000);

          if ($DebugTestMode) {
            console.log("‚úÖ ControlWindowManager initialization complete");
          }
        }

        // NEW: Monitor localStorage changes in real-time
        setupStorageWatcher() {
          if ($DebugTestMode) {
            console.log(
              "üîç STORAGE: Setting up real-time localStorage monitoring..."
            );
          }

          // Monitor specific keys for changes
          const watchedKeys = [
            "restore_ai",
            "show_ai_window",
            "ai_command",
            "window_command",
            "ai_minimized",
            "control_ai_minimized",
            "ai_heartbeat",
            "force_control_check",
            "ai_restoring",
            "ai_restored",
          ];

          // Store current values
          this.lastStorageState = {};
          watchedKeys.forEach((key) => {
            this.lastStorageState[key] = localStorage.getItem(key);
          });

          // Check for changes every 100ms
          this.storageWatcher = setInterval(() => {
            watchedKeys.forEach((key) => {
              const currentValue = localStorage.getItem(key);
              const lastValue = this.lastStorageState[key];

              if (currentValue !== lastValue) {
                if ($DebugTestMode) {
                  //console.log(`üîç STORAGE: Key "${key}" changed:`);
                  //console.log(`  Previous: ${lastValue}`);
                  //console.log(`  Current:  ${currentValue}`);
                  //console.log(`  Timestamp: ${new Date().toISOString()}`);
                }

                this.lastStorageState[key] = currentValue;
              }
            });
          }, 100);

          if ($DebugTestMode) {
            /*console.log(
                          "‚úÖ STORAGE: Real-time monitoring enabled for keys:",
                          watchedKeys
                        );*/
          }
        }

        checkAllWindowStates() {
          if ($DebugTestMode) {
            /*console.log("üîç === CHECKING ALL WINDOW STATES ===");
            console.log("üîç Timestamp:", new Date().toISOString());

            // Simple localStorage logging (no arrays to track)
            console.log("üîç Key localStorage values:");
            console.log(
              "  - control_ai_minimized:",
              localStorage.getItem("control_ai_minimized")
            );
            console.log(
              "  - ai_minimized:",
              localStorage.getItem("ai_minimized")
            );
            console.log(
              "  - control_transcript_minimized:",
              localStorage.getItem("control_transcript_minimized")
            );
            console.log(
              "  - transcript_minimized:",
              localStorage.getItem("transcript_minimized")
            );
            console.log(
              "  - ai_heartbeat:",
              localStorage.getItem("ai_heartbeat")
            );
            console.log(
              "  - transcript_heartbeat:",
              localStorage.getItem("transcript_heartbeat")
            );*/
          }

          //this.checkTranscriptState();
          this.checkAIState();
          this.forceButtonVisibilityCheck();

          if ($DebugTestMode) {
            //console.log("üîç Final button states:");
            const transcriptBtn = document.getElementById("transcriptBtn");
            const aiBtn = document.getElementById("aiBtn");
            //console.log("üîç   Transcript button display:",transcriptBtn?.style.display);
            //console.log("üîç   AI button display:", aiBtn?.style.display);
            //console.log("üîç === WINDOW STATES CHECK COMPLETE ===");
          }
        }
        checkAIState() {
          if ($DebugTestMode) {
            //console.log("ü§ñ === CHECKING AI STATE ===");
            //console.log("ü§ñ Current time:", Date.now());
            //console.log("ü§ñ Current aiMinimized:", this.aiMinimized);
            //console.log("ü§ñ Current aiRestoring:", this.aiRestoring);
          }

          if (this.aiRestoring) {
            if ($DebugTestMode) {
              /*console.log(
                "üîÑ AI restoration in progress, skipping state check"
              );*/
            }
            return;
          }

          const controlMinimized = localStorage.getItem("control_ai_minimized");
          const aiMinimized = localStorage.getItem("ai_minimized");
          const forceCheck = localStorage.getItem("force_control_check");
          const aiHeartbeat = localStorage.getItem("ai_heartbeat");
          const aiWindowState = localStorage.getItem("ai_window_state");
          const currentTime = Date.now();

          if ($DebugTestMode) {
            //console.log("ü§ñ Storage values:");
            //console.log("  - control_ai_minimized:", controlMinimized);
            //console.log("  - ai_minimized:", aiMinimized);
            //console.log("  - ai_window_state:", aiWindowState);
            //console.log("  - ai_heartbeat:", aiHeartbeat);
            //console.log("  - force_control_check:", forceCheck);
          }

          // Check AI heartbeat age
          if (aiHeartbeat) {
            const heartbeatAge = currentTime - parseInt(aiHeartbeat);
            if ($DebugTestMode) {
              //console.log("üíì AI heartbeat analysis:");
              //console.log("  - Raw value:", aiHeartbeat);
              //console.log("  - Age:", heartbeatAge, "ms");
              //console.log("  - Is stale (>30s):", heartbeatAge > 30000);
            }

            // If no heartbeat for 30s, assume minimized
            if (heartbeatAge > 30000) {
              if ($DebugTestMode) {
                //console.log("üíì AI heartbeat stale - assuming AI is minimized");
              }
              this.aiMinimized = true;
              this.showAIButton();
              return;
            }
          } else {
            if ($DebugTestMode) {
              //console.log("üíì No AI heartbeat found - AI may not be running");
            }
          }

          if (forceCheck) {
            if ($DebugTestMode) {
              //console.log("üîÑ Force check triggered, clearing flag");
            }
            localStorage.removeItem("force_control_check");
          }

          const shouldShowAIButton =
            controlMinimized === "true" || aiMinimized === "true";

          if ($DebugTestMode) {
            //console.log("ü§ñ Decision logic:");
            /*console.log(
              "  - controlMinimized === 'true':",
              controlMinimized === "true"
            );*/
            //console.log("  - aiMinimized === 'true':", aiMinimized === "true");
            //console.log("  - shouldShowAIButton:", shouldShowAIButton);
          }

          if (shouldShowAIButton) {
            if ($DebugTestMode) {
              //console.log("‚úÖ AI should be minimized - showing button");
            }
            this.aiMinimized = true;
            this.showAIButton();
          } else {
            if ($DebugTestMode) {
              //console.log("‚ùå AI should not be minimized - hiding button");
            }
            this.aiMinimized = false;
            this.hideAIButton();
          }

          if ($DebugTestMode) {
            //console.log("ü§ñ === AI STATE CHECK COMPLETE ===");
          }
        }
        // üîß NEW: Force button visibility check
        forceButtonVisibilityCheck() {
          if ($DebugTestMode) {
            //console.log("üîß === FORCE BUTTON VISIBILITY CHECK ===");
            //console.log("üîß Checking explicit minimized flags...");
          }

          const controlAiMinimized = localStorage.getItem(
            "control_ai_minimized"
          );
          const controlTranscriptMinimized = localStorage.getItem(
            "control_transcript_minimized"
          );
          const aiMinimized = localStorage.getItem("ai_minimized");
          const transcriptMinimized = localStorage.getItem(
            "transcript_minimized"
          );

          if ($DebugTestMode) {
            //console.log("üîß Minimized flags:");
            //console.log("  - control_ai_minimized:", controlAiMinimized);
            //console.log( "  - control_transcript_minimized:",controlTranscriptMinimized );
            //console.log("  - ai_minimized:", aiMinimized);
            //console.log("  - transcript_minimized:", transcriptMinimized);
          }

          // Force AI button check
          if (controlAiMinimized === "true" || aiMinimized === "true") {
            if ($DebugTestMode) {
              //console.log( "üîß FORCE: AI should be minimized - forcing button visible");
            }
            this.aiMinimized = true;
            this.showAIButton();
          }

          // Force transcript button check
          /*if (
            controlTranscriptMinimized === "true" ||
            transcriptMinimized === "true"
          ) {
            if ($DebugTestMode) {
              //console.log(  "üîß FORCE: Transcript should be minimized - forcing button visible" );
            }
            this.transcriptMinimized = true;
            this.showTranscriptButton();
          }*/

          if ($DebugTestMode) {
            //console.log("üîß === FORCE CHECK COMPLETE ===");
          }
        }
        /*checkTranscriptState() {
          if ($DebugTestMode) {
            //console.log("üí¨ === CHECKING TRANSCRIPT STATE ===");
            //console.log("üí¨ Current time:", Date.now());
            // console.log("üí¨ Current transcriptMinimized:", this.transcriptMinimized);
          }

          const isMinimized = localStorage.getItem(
            "control_transcript_minimized"
          );
          const transcriptMinimized = localStorage.getItem(
            "transcript_minimized"
          );
          const transcriptHeartbeat = localStorage.getItem(
            "transcript_heartbeat"
          );
          const forceCheck = localStorage.getItem("force_control_check");

          if ($DebugTestMode) {
            // console.log("üí¨ Storage values:");
            //console.log("  - control_transcript_minimized:", isMinimized);
            //console.log("  - transcript_minimized:", transcriptMinimized);
            //console.log("  - transcript_heartbeat:", transcriptHeartbeat);
            // console.log("  - force_control_check:", forceCheck);
          }

          // Check heartbeat age
          if (transcriptHeartbeat) {
            const heartbeatAge = Date.now() - parseInt(transcriptHeartbeat);
            if ($DebugTestMode) {
              //console.log("üí¨ Heartbeat analysis:");
              //console.log("  - Age:", heartbeatAge, "ms");
              //console.log("  - Is stale (>30s):", heartbeatAge > 30000);
            }

            // If no heartbeat for 30s, assume minimized
            if (heartbeatAge > 30000) {
              if ($DebugTestMode) {
                //console.log("üí¨ Heartbeat stale - assuming transcript is minimized");
              }
              this.transcriptMinimized = true;
              this.showTranscriptButton();
              return;
            }
          }

          if (isMinimized === "true" || transcriptMinimized === "true") {
            if ($DebugTestMode) {
              //console.log("‚úÖ Transcript explicitly marked as minimized");
            }
            this.transcriptMinimized = true;
            this.showTranscriptButton();
            return;
          }

          if ($DebugTestMode) {
            console.log(
              "‚ùå Transcript not marked as minimized - hiding button"
            );
          }
          this.transcriptMinimized = false;
          this.hideTranscriptButton();
        }*/

        showAIButton() {
          if ($DebugTestMode) {
            //console.log("üëÅÔ∏è showAIButton called");
          }
          const aiBtn = document.getElementById("aiBtn");
          if (aiBtn) {
            if ($DebugTestMode) {
              //console.log("üëÅÔ∏è AI button element found, showing...");
            }

            // CRITICAL FIX: Reset any existing classes first to prevent double animation
            aiBtn.classList.remove("show", "has-notification", "receiving");
            aiBtn.style.display = "block";
            aiBtn.style.pointerEvents = "auto";
            aiBtn.style.webkitAppRegion = "no-drag";
            aiBtn.classList.add("show");
            aiBtn.classList.add("has-notification");
            if ($DebugTestMode) {
              //console.log("üëÅÔ∏è AI button shown successfully");
              //console.log("üëÅÔ∏è AI button display:", aiBtn.style.display);
              //console.log("üëÅÔ∏è AI button classes:", Array.from(aiBtn.classList));
            }
          } else {
            if ($DebugTestMode) {
              console.error("‚ùå AI button element not found!");
            }
          }
        }

        cleanupRestoreMessages() {
          if ($DebugTestMode) {
            console.log(
              "üßπ CONTROL: ========== CLEANUP RESTORE MESSAGES =========="
            );
          }

          const keysToClean = [
            "ai_command",
            "window_command",
            "restore_ai",
            "show_ai_window",
            "force_control_check",
            "control_restore_command",
            "restore_ai_request",
            "ai_restore_command",
            "window_restore_ai",
          ];

          keysToClean.forEach((key) => {
            const value = localStorage.getItem(key);
            if (value) {
              if ($DebugTestMode) {
                console.log(`üßπ CONTROL: Removing ${key}:`, value);
              }
              localStorage.removeItem(key);
            }
          });

          // Clean up numbered restore messages
          for (let i = 0; i < 10; i++) {
            const key = `ai_restore_${i}`;
            const value = localStorage.getItem(key);
            if (value) {
              if ($DebugTestMode) {
                console.log(`üßπ CONTROL: Removing ${key}:`, value);
              }
              localStorage.removeItem(key);
            }
          }

          if ($DebugTestMode) {
            console.log("üßπ CONTROL: Restore messages cleanup completed");
          }
        }

        hideAIButton() {
          if ($DebugTestMode) {
            //console.log("üëÅÔ∏è hideAIButton called");
          }
          const aiBtn = document.getElementById("aiBtn");
          if (aiBtn) {
            if ($DebugTestMode) {
              // console.log("üëÅÔ∏è AI button element found, hiding...");
            }
            aiBtn.style.display = "none";
            aiBtn.classList.remove("show");
            aiBtn.classList.remove("has-notification");
            if ($DebugTestMode) {
              //console.log("üëÅÔ∏è AI button hidden successfully");
              //console.log("üëÅÔ∏è AI button display:", aiBtn.style.display);
              //console.log("üëÅÔ∏è AI button classes:", Array.from(aiBtn.classList));
            }
          } else {
            if ($DebugTestMode) {
              console.error("‚ùå AI button element not found!");
            }
          }
        }

        /*showTranscriptButton() {
          if ($DebugTestMode) {
            //console.log("üëÅÔ∏è showTranscriptButton called");
          }
          const transcriptBtn = document.getElementById("transcriptBtn");
          if (transcriptBtn) {
            if ($DebugTestMode) {
              console.log("üëÅÔ∏è Transcript button element found, showing...");
              console.log(
                "üëÅÔ∏è Button classes before:",
                Array.from(transcriptBtn.classList)
              );
              console.log(
                "üëÅÔ∏è Button display before:",
                transcriptBtn.style.display
              );
            }

            transcriptBtn.style.display = "block";
            transcriptBtn.classList.add("show");
            transcriptBtn.classList.add("has-notification");

            if ($DebugTestMode) {
              console.log("üëÅÔ∏è Transcript button shown successfully");
              console.log(
                "üëÅÔ∏è Button classes after:",
                Array.from(transcriptBtn.classList)
              );
              console.log(
                "üëÅÔ∏è Button display after:",
                transcriptBtn.style.display
              );
            }
          } else {
            if ($DebugTestMode) {
              //console.error("‚ùå Transcript button element not found!");
            }
          }
        }

        hideTranscriptButton() {
          if ($DebugTestMode) {
            console.log("üëÅÔ∏è hideTranscriptButton called");
          }

          const transcriptBtn = document.getElementById("transcriptBtn");
          if (transcriptBtn) {
            if ($DebugTestMode) {
              console.log("üëÅÔ∏è Transcript button element found, hiding...");
              console.log(
                "üëÅÔ∏è Button classes before:",
                Array.from(transcriptBtn.classList)
              );
              console.log(
                "üëÅÔ∏è Button display before:",
                transcriptBtn.style.display
              );
            }

            // üîß NEW: Comprehensive hiding
            transcriptBtn.style.display = "none";
            transcriptBtn.classList.remove("show");
            transcriptBtn.classList.remove("has-notification");
            transcriptBtn.classList.remove("receiving");

            if ($DebugTestMode) {
              console.log("üëÅÔ∏è Transcript button hidden successfully");
              console.log(
                "üëÅÔ∏è Button classes after:",
                Array.from(transcriptBtn.classList)
              );
              console.log(
                "üëÅÔ∏è Button display after:",
                transcriptBtn.style.display
              );
            }
          } else {
            if ($DebugTestMode) {
              console.error("‚ùå Transcript button element not found!");
            }
          }
        }*/

        setupWindowCommunication() {
          if ($DebugTestMode) {
            console.log("üîß Setting up window communication...");
          }

          // Enhanced localStorage monitoring with more detailed logging
          const checkWindowMessages = () => {
            try {
              // Enhanced force check detection
              const forceCheck = localStorage.getItem("force_control_check");
              if (forceCheck) {
                const checkAge = Date.now() - parseInt(forceCheck);
                if ($DebugTestMode) {
                  console.log("üîÑ ENHANCED Force check detected:");
                  console.log("  - Force check value:", forceCheck);
                  console.log("  - Force check age:", checkAge);
                  console.log("  - Current restoreId:", this.currentRestoreId);
                  console.log("  - AI restoring:", this.aiRestoring);
                }

                this.checkAIState();
              }

              // Enhanced restore message checking with individual logging
              const allRestoreKeys = [
                "restore_ai",
                "show_ai_window",
                "ai_command",
                "window_command",
                "control_restore_command",
                "ai_restore_command",
              ];

              allRestoreKeys.forEach((key) => {
                const value = localStorage.getItem(key);
                if (value) {
                  if ($DebugTestMode) {
                    console.log(`üì® üîç ENHANCED Found ${key}:`, value);
                  }
                  try {
                    const parsed = JSON.parse(value);
                    if ($DebugTestMode) {
                      console.log(`üì® üîç ENHANCED Parsed ${key}:`, parsed);
                      console.log(`  - Type: ${parsed.type}`);
                      console.log(`  - Timestamp: ${parsed.timestamp}`);
                      console.log(
                        `  - Age: ${Date.now() - parsed.timestamp}ms`
                      );
                      console.log(`  - RestoreId: ${parsed.restoreId}`);
                      console.log(`  - Source: ${parsed.source}`);
                    }

                    if (
                      parsed.timestamp &&
                      Date.now() - parsed.timestamp < 10000
                    ) {
                      if ($DebugTestMode) {
                        console.log(
                          `üì® ‚úÖ ENHANCED ${key} is recent, processing...`
                        );
                      }
                    } else {
                      if ($DebugTestMode) {
                        console.log(
                          `üì® ‚ö†Ô∏è ENHANCED ${key} is old (${
                            Date.now() - parsed.timestamp
                          }ms), ignoring...`
                        );
                      }
                    }
                  } catch (e) {
                    if ($DebugTestMode) {
                      console.log(`üì® ENHANCED ${key} is not JSON:`, value);
                    }
                  }
                }
              });
            } catch (error) {
              if ($DebugTestMode) {
                console.warn(
                  "‚ùå Error in ENHANCED checkWindowMessages:",
                  error
                );
              }
            }
          };

          setInterval(checkWindowMessages, 250);

          // Listen for more custom events
          const customEvents = [
            "controlRestoreAI",
            "restoreAI",
            "aiRestore",
            "windowRestore",
            "showAI",
          ];
          customEvents.forEach((eventName) => {
            window.addEventListener(eventName, (event) => {
              if ($DebugTestMode) {
                console.log(
                  `üéØ Received custom event "${eventName}":`,
                  event.detail
                );
              }
            });
          });

          if ($DebugTestMode) {
            console.log("‚úÖ Window communication setup complete");
          }
        }

        testAIConnection() {
          if ($DebugTestMode) {
            console.log("üèì CONTROL: ENHANCED Testing AI window connection...");
            console.log("üèì CONTROL: Current time:", Date.now());
            console.log(
              "üèì CONTROL: Current restoreId:",
              this.currentRestoreId
            );
            console.log("üèì CONTROL: AI restoring state:", this.aiRestoring);
          }

          const pingMessage = {
            type: "AI_PING_TEST",
            timestamp: Date.now(),
            source: "control",
            testId: Math.random().toString(36).substr(2, 9),
            restoreId: this.currentRestoreId,
          };

          if ($DebugTestMode) {
            console.log("üèì CONTROL: ENHANCED Ping message:", pingMessage);
          }

          // Store with multiple keys and enhanced logging
          const pingKeys = [
            "ai_ping_test",
            "control_ping",
            "ping_test",
            "ai_connection_test",
            "window_ping",
          ];

          pingKeys.forEach((key) => {
            localStorage.setItem(key, JSON.stringify(pingMessage));
            if ($DebugTestMode) {
              console.log(`üèì CONTROL: Stored ping with key: ${key}`);
            }
          });

          if ($DebugTestMode) {
            console.log(
              "üèì CONTROL: ENHANCED Sent ping test with testId:",
              pingMessage.testId
            );
          }

          // Enhanced response checking with detailed logging
          setTimeout(() => {
            const response1 = localStorage.getItem("ai_ping_response");
            const response2 = localStorage.getItem("ping_response");
            const response3 = localStorage.getItem("ai_pong");
            const response4 = localStorage.getItem("ai_connection_response");

            if ($DebugTestMode) {
              console.log("üèì CONTROL: ENHANCED Checking ping responses...");
              console.log("üèì CONTROL: ai_ping_response:", response1);
              console.log("üèì CONTROL: ping_response:", response2);
              console.log("üèì CONTROL: ai_pong:", response3);
              console.log("üèì CONTROL: ai_connection_response:", response4);
            }

            const hasResponse =
              response1 || response2 || response3 || response4;

            if (hasResponse) {
              if ($DebugTestMode) {
                console.log(
                  "üèì CONTROL: ‚úÖ ENHANCED Received ping response - AI is responsive"
                );
              }

              // Clean up
              [
                "ai_ping_response",
                "ping_response",
                "ai_pong",
                "ai_connection_response",
              ].forEach((key) => {
                localStorage.removeItem(key);
              });
            } else {
              if ($DebugTestMode) {
                console.log(
                  "üèì CONTROL: ‚ùå ENHANCED No ping response received - AI window may not be responding"
                );
              }
            }

            // Clean up ping messages
            pingKeys.forEach((key) => {
              localStorage.removeItem(key);
            });
          }, 2000);
        }

        // AI Window Event Handlers with enhanced debugging
        onAIMinimizing() {
          if ($DebugTestMode) {
            console.log("üîÑ === onAIMinimizing START ===");
            console.log("üîÑ Current time:", Date.now());
            console.log("üîÑ Current state - aiMinimized:", this.aiMinimized);
            console.log("üîÑ Current state - aiRestoring:", this.aiRestoring);
          }

          const aiBtn = document.getElementById("aiBtn");
          if (aiBtn) {
            if ($DebugTestMode) {
              console.log("üîÑ Adding 'receiving' class to AI button");
              console.log(
                "üîÑ Button classes before:",
                Array.from(aiBtn.classList)
              );
            }
            aiBtn.classList.add("receiving");
            if ($DebugTestMode) {
              console.log(
                "üîÑ Button classes after:",
                Array.from(aiBtn.classList)
              );
            }
          } else {
            if ($DebugTestMode) {
              console.error("‚ùå AI button not found in onAIMinimizing");
            }
          }
          if ($DebugTestMode) {
            console.log("üîÑ === onAIMinimizing END ===");
          }
        }

        onAIMinimized() {
          if ($DebugTestMode) {
            console.log("üîÑ === onAIMinimized START ===");
            console.log("üîÑ Setting aiMinimized = true");
            console.log("üîÑ Previous aiMinimized:", this.aiMinimized);
          }

          this.aiMinimized = true;
          if ($DebugTestMode) {
            console.log("üîÑ New aiMinimized:", this.aiMinimized);
          }

          const aiBtn = document.getElementById("aiBtn");

          if (aiBtn) {
            if ($DebugTestMode) {
              console.log("üîÑ Updating AI button classes");
              console.log(
                "üîÑ Button classes before update:",
                Array.from(aiBtn.classList)
              );
            }
            aiBtn.classList.remove("receiving");
            aiBtn.classList.add("show");
            aiBtn.classList.add("has-notification");
            if ($DebugTestMode) {
              console.log(
                "üîÑ AI button classes after minimized:",
                Array.from(aiBtn.classList)
              );
              console.log("üîÑ AI button display:", aiBtn.style.display);
            }
          } else {
            if ($DebugTestMode) {
              console.error("‚ùå AI button not found in onAIMinimized");
            }
          }

          if ($DebugTestMode) {
            console.log("üîÑ Setting localStorage flags...");
          }
          localStorage.setItem("control_ai_minimized", "true");
          if ($DebugTestMode) {
            console.log("üîÑ Set control_ai_minimized to true");
          }

          // Verify the localStorage was set
          const verification = localStorage.getItem("control_ai_minimized");
          if ($DebugTestMode) {
            console.log(
              "üîÑ Verification - control_ai_minimized is now:",
              verification
            );
            console.log("üîÑ === onAIMinimized END ===");
          }
        }

        onAIRestoring() {
          if ($DebugTestMode) {
            console.log("üîÑ === onAIRestoring START ===");
            console.log("üîÑ AI window is restoring - showing loading state");
            console.log("üîÑ Previous aiRestoring:", this.aiRestoring);
            console.log("üîÑ Previous aiMinimized:", this.aiMinimized);
          }

          this.aiRestoring = true;
          this.restoreAttemptTime = Date.now();
          this.lastRestoreTime = Date.now();

          if ($DebugTestMode) {
            console.log(
              "üîÑ Set aiRestoring = true, restoreAttemptTime =",
              this.restoreAttemptTime
            );
            console.log("üîÑ Set lastRestoreTime =", this.lastRestoreTime);
          }

          const aiBtn = document.getElementById("aiBtn");
          if (aiBtn) {
            if ($DebugTestMode) {
              console.log("üîÑ Updating AI button for restoring state");
              console.log(
                "üîÑ Button classes before:",
                Array.from(aiBtn.classList)
              );
              console.log("üîÑ Button display before:", aiBtn.style.display);
            }

            aiBtn.classList.remove("has-notification");
            aiBtn.classList.add("receiving");
            // Keep the button visible during restoration
            aiBtn.style.display = "block";
            aiBtn.classList.add("show");

            if ($DebugTestMode) {
              console.log(
                "üîÑ AI button classes after restoring:",
                Array.from(aiBtn.classList)
              );
              console.log("üîÑ AI button display:", aiBtn.style.display);
            }
          } else {
            if ($DebugTestMode) {
              console.error("‚ùå AI button not found in onAIRestoring");
            }
          }
          if ($DebugTestMode) {
            console.log("üîÑ === onAIRestoring END ===");
          }
        }

        onAIRestored(data = {}) {
          // Add validation to ensure this is a REAL response from AI window
          if (!data || !data.restoreId || data.source !== "ai") {
            if ($DebugTestMode) {
              console.log(
                "‚ö†Ô∏è Ignoring onAIRestored - not a valid AI response:",
                data
              );
            }
            return;
          }

          // Check if this matches our current restore ID
          if (data.restoreId !== this.currentRestoreId) {
            if ($DebugTestMode) {
              console.log("‚ö†Ô∏è Ignoring onAIRestored - wrong restore ID");
            }
            return;
          }

          if ($DebugTestMode) {
            console.log("üéâ === onAIRestored START ===");
            console.log("üéâ Restore data received:", data);
            console.log("üéâ Current aiRestoring:", this.aiRestoring);
            console.log("üéâ Current currentRestoreId:", this.currentRestoreId);
            console.log("üéâ Message restoreId:", data.restoreId);
          }

          // Check if this is for current restore
          if (!this.aiRestoring) {
            if ($DebugTestMode) {
              console.log(
                "‚ö†Ô∏è Ignoring restore completion - aiRestoring is false"
              );
            }
            return;
          }

          if (!this.currentRestoreId) {
            if ($DebugTestMode) {
              console.log(
                "‚ö†Ô∏è Ignoring restore completion - no active restore ID"
              );
            }
            return;
          }

          if ($DebugTestMode) {
            console.log("üéâ AI window confirmed restoration");
          }

          // Update states with detailed logging
          if ($DebugTestMode) {
            console.log("üéâ Updating states...");
            console.log("üéâ Before - aiMinimized:", this.aiMinimized);
            console.log("üéâ Before - aiRestoring:", this.aiRestoring);
          }

          this.aiMinimized = false;
          this.aiRestoring = false;
          this.currentRestoreId = null;

          if ($DebugTestMode) {
            console.log("üéâ After - aiMinimized:", this.aiMinimized);
            console.log("üéâ After - aiRestoring:", this.aiRestoring);
            console.log("üéâ After - currentRestoreId:", this.currentRestoreId);
          }

          const aiBtn = document.getElementById("aiBtn");
          if (aiBtn) {
            if ($DebugTestMode) {
              console.log("‚úÖ Hiding AI button after successful restore");
              console.log(
                "‚úÖ Button classes before hide:",
                Array.from(aiBtn.classList)
              );
              console.log(
                "‚úÖ Button display before hide:",
                aiBtn.style.display
              );
            }

            aiBtn.classList.remove("receiving", "show", "has-notification");
            aiBtn.style.display = "none";

            if ($DebugTestMode) {
              console.log(
                "‚úÖ Button classes after hide:",
                Array.from(aiBtn.classList)
              );
              console.log("‚úÖ Button display after hide:", aiBtn.style.display);
            }
          }

          // Clear localStorage flags with verification
          if ($DebugTestMode) {
            console.log("üéâ Clearing localStorage flags...");
            console.log(
              "üéâ Before clear - control_ai_minimized:",
              localStorage.getItem("control_ai_minimized")
            );
            console.log(
              "üéâ Before clear - ai_minimized:",
              localStorage.getItem("ai_minimized")
            );
          }

          if ($DebugTestMode) {
            console.log(
              "üö®‚úÖüö®‚úÖüö®‚úÖüö®‚úÖ ALERT: CONTROL_AI_MINIMIZED HAS BEEN RESET!"
            );
          }
          localStorage.removeItem("control_ai_minimized");
          localStorage.removeItem("ai_minimized");

          if ($DebugTestMode) {
            console.log(
              "üéâ After clear - control_ai_minimized:",
              localStorage.getItem("control_ai_minimized")
            );
            console.log(
              "üéâ After clear - ai_minimized:",
              localStorage.getItem("ai_minimized")
            );
          }

          if ($DebugTestMode) {
            console.log("üéâ === onAIRestored END ===");
          }
        }

        onAIRestoreFailed() {
          if ($DebugTestMode) {
            console.log("‚ùå === onAIRestoreFailed START ===");
            console.log("‚ùå AI restore failed - keeping button visible");
            console.log("‚ùå Current aiRestoring:", this.aiRestoring);
            console.log("‚ùå Current aiMinimized:", this.aiMinimized);
            console.log("‚ùå Current currentRestoreId:", this.currentRestoreId);
          }

          this.aiRestoring = false;
          this.aiMinimized = true; // Keep this true so button stays
          this.currentRestoreId = null;

          if ($DebugTestMode) {
            console.log("‚ùå Set aiRestoring = false, aiMinimized = true");
            console.log("‚ùå New aiRestoring:", this.aiRestoring);
            console.log("‚ùå New aiMinimized:", this.aiMinimized);
          }

          const aiBtn = document.getElementById("aiBtn");
          if (aiBtn) {
            if ($DebugTestMode) {
              console.log("‚ùå Restoring AI button after failed restore");
              console.log(
                "‚ùå Button classes before restore:",
                Array.from(aiBtn.classList)
              );
              console.log(
                "‚ùå Button display before restore:",
                aiBtn.style.display
              );
            }

            aiBtn.classList.remove("receiving");
            aiBtn.classList.add("show");
            aiBtn.classList.add("has-notification");
            aiBtn.style.display = "block"; // Force visible

            if ($DebugTestMode) {
              console.log(
                "‚ùå AI button classes after failed restore:",
                Array.from(aiBtn.classList)
              );
              console.log("‚ùå AI button display:", aiBtn.style.display);
            }
          }

          // Don't clear the localStorage flags - keep them so button stays
          if ($DebugTestMode) {
            console.log("üîÑ Button restored after failed restore attempt");
          }
          if ($DebugTestMode) {
            console.log("‚ùå === onAIRestoreFailed END ===");
          }
        }

        // Transcript Window Event Handlers
        /* onTranscriptMinimizing() {
          const transcriptBtn = document.getElementById("transcriptBtn");
          if (transcriptBtn) {
            transcriptBtn.classList.add("receiving");
          }
        }

       onTranscriptMinimized() {
          if ($DebugTestMode) {
            console.log("üí¨ Transcript confirmed minimized");
          }
          this.transcriptMinimized = true;
          const transcriptBtn = document.getElementById("transcriptBtn");

          if (transcriptBtn) {
            if ($DebugTestMode) {
              console.log("üí¨ Updating transcript button for minimized state");
              console.log(
                "üí¨ Button classes before:",
                Array.from(transcriptBtn.classList)
              );
              console.log(
                "üí¨ Button display before:",
                transcriptBtn.style.display
              );
            }

            transcriptBtn.classList.remove("receiving");
            transcriptBtn.classList.add("show");
            transcriptBtn.classList.add("has-notification");
            transcriptBtn.style.display = "block"; // Force visible

            if ($DebugTestMode) {
              console.log(
                "üí¨ Button classes after:",
                Array.from(transcriptBtn.classList)
              );
              console.log(
                "üí¨ Button display after:",
                transcriptBtn.style.display
              );
            }
          }

          // Set flag with timestamp for validation
          const timestamp = Date.now();
          localStorage.setItem("control_transcript_minimized", "true");
          localStorage.setItem(
            "control_transcript_minimized_time",
            timestamp.toString()
          );

          if ($DebugTestMode) {
            console.log(
              "üí¨ Set control_transcript_minimized flags:",
              timestamp
            );
          }

          // Clear heartbeat since window is minimized
          localStorage.removeItem("transcript_heartbeat");
        }*/

        /*onTranscriptRestoring() {
          const transcriptBtn = document.getElementById("transcriptBtn");
          if (transcriptBtn) {
            transcriptBtn.classList.remove("has-notification");
            transcriptBtn.classList.add("receiving");
          }
        }*/

        /*onTranscriptRestored() {
          if ($DebugTestMode) {
            console.log("üí¨ Transcript confirmed restored/visible");
          }

          // üîß NEW: Ensure state is consistent
          this.transcriptMinimized = false;

          // üîß NEW: Hide button immediately
          this.hideTranscriptButton();

          // üîß NEW: Clear ALL transcript minimized flags
          if ($DebugTestMode) {
            console.log(
              "üö®üî•üí•‚ö†Ô∏è‚ùå ALERT: CONTROL_TRANSCRIPT_MINIMIZED HAS BEEN RESET!"
            );
          }
          localStorage.removeItem("control_transcript_minimized");
          localStorage.removeItem("control_transcript_minimized_time");
          localStorage.removeItem("transcript_minimized");

          // üîß NEW: Set fresh heartbeat
          localStorage.setItem("transcript_heartbeat", Date.now().toString());

          if ($DebugTestMode) {
            console.log("üí¨ Transcript state reset to visible/active");
          }
        }*/

        // Find the restoreAI function in your ControlWindowManager class and replace it with this fixed version:

        restoreAI() {
          if ($DebugTestMode) {
            console.log("üéØüéØüéØ === ULTRA-ENHANCED AI RESTORE START ===");
            console.log(
              "üéØ Function entry timestamp:",
              new Date().toISOString()
            );
            console.log("üéØ Function entry time (ms):", Date.now());
            console.log("üéØ Restore attempt #:", ++this.restoreAttempts);
            console.log("üéØ Stack trace at entry:", new Error().stack);
          }

          // PHASE 1: STATE ANALYSIS
          if ($DebugTestMode) {
            console.log("üéØ === PHASE 1: CURRENT STATE ANALYSIS ===");
            console.log("üéØ Current aiMinimized:", this.aiMinimized);
            console.log("üéØ Current aiRestoring:", this.aiRestoring);
            console.log("üéØ Current currentRestoreId:", this.currentRestoreId);
            console.log("üéØ Current restoreAttempts:", this.restoreAttempts);
            console.log("üéØ Current lastRestoreTime:", this.lastRestoreTime);

            // Check localStorage BEFORE any changes
            console.log("üéØ === LOCALSTORAGE BEFORE RESTORE ===");
            console.log(
              "üéØ control_ai_minimized:",
              localStorage.getItem("control_ai_minimized")
            );
            console.log(
              "üéØ ai_minimized:",
              localStorage.getItem("ai_minimized")
            );
            console.log(
              "üéØ ai_heartbeat:",
              localStorage.getItem("ai_heartbeat")
            );
            console.log(
              "üéØ ai_window_state:",
              localStorage.getItem("ai_window_state")
            );
            console.log("üéØ restore_ai:", localStorage.getItem("restore_ai"));
            console.log(
              "üéØ ai_restore_request:",
              localStorage.getItem("ai_restore_request")
            );
          }

          // PHASE 2: DUPLICATE CHECK
          if ($DebugTestMode) {
            console.log("üéØ === PHASE 2: DUPLICATE PREVENTION CHECK ===");
          }
          if (this.aiRestoring) {
            if ($DebugTestMode) {
              console.warn("‚ö†Ô∏è DUPLICATE RESTORE DETECTED!");
              console.warn("‚ö†Ô∏è aiRestoring is already true, aborting");
              console.warn("‚ö†Ô∏è currentRestoreId:", this.currentRestoreId);
              console.warn("‚ö†Ô∏è lastRestoreTime:", this.lastRestoreTime);
              console.warn(
                "‚ö†Ô∏è Time since last restore:",
                Date.now() - this.lastRestoreTime,
                "ms"
              );
            }
            return;
          }

          // PHASE 3: UI IMMEDIATE RESPONSE
          if ($DebugTestMode) {
            console.log("üéØ === PHASE 3: IMMEDIATE UI RESPONSE ===");
          }
          const aiBtn = document.getElementById("aiBtn");
          if (aiBtn) {
            if ($DebugTestMode) {
              console.log("üéØ AI button found, current state:");
              console.log("üéØ   display:", aiBtn.style.display);
              console.log("üéØ   classes:", Array.from(aiBtn.classList));
              console.log("üéØ   disabled:", aiBtn.disabled);
              console.log("üéØ Hiding AI button immediately...");
            }
            aiBtn.style.display = "none";
            aiBtn.classList.remove("show", "has-notification", "receiving");

            if ($DebugTestMode) {
              console.log("üéØ AI button after hiding:");
              console.log("üéØ   display:", aiBtn.style.display);
              console.log("üéØ   classes:", Array.from(aiBtn.classList));
            }
          } else {
            if ($DebugTestMode) {
              console.error("‚ùå AI button element not found!");
            }
          }

          // PHASE 4: STATE UPDATES
          if ($DebugTestMode) {
            console.log("üéØ === PHASE 4: INTERNAL STATE UPDATES ===");
            const previousAiMinimized = this.aiMinimized;
            const previousAiRestoring = this.aiRestoring;
            const previousRestoreId = this.currentRestoreId;

            console.log("üéØ Previous states:");
            console.log("üéØ   aiMinimized:", previousAiMinimized, "‚Üí false");
            console.log("üéØ   aiRestoring:", previousAiRestoring, "‚Üí false");
            console.log("üéØ   currentRestoreId:", previousRestoreId, "‚Üí null");
          }

          this.aiMinimized = false;
          this.aiRestoring = false;
          this.currentRestoreId = null;

          if ($DebugTestMode) {
            console.log("üéØ New states confirmed:");
            console.log("üéØ   aiMinimized:", this.aiMinimized);
            console.log("üéØ   aiRestoring:", this.aiRestoring);
            console.log("üéØ   currentRestoreId:", this.currentRestoreId);
          }

          // PHASE 5: MESSAGE CREATION
          if ($DebugTestMode) {
            console.log("üéØ === PHASE 5: MESSAGE CREATION ===");
          }
          const restoreId =
            Date.now() + Math.random().toString(36).substr(2, 5);
          const messageData = {
            type: "RESTORE_AI",
            timestamp: Date.now(),
            source: "control",
            restoreId: restoreId,
            attempt: this.restoreAttempts,
            userInitiated: true,
          };

          if ($DebugTestMode) {
            console.log("üéØ Created restore message:");
            console.log("üéØ   type:", messageData.type);
            console.log("üéØ   timestamp:", messageData.timestamp);
            console.log("üéØ   source:", messageData.source);
            console.log("üéØ   restoreId:", messageData.restoreId);
            console.log("üéØ   attempt:", messageData.attempt);
            console.log(
              "üéØ   Full message:",
              JSON.stringify(messageData, null, 2)
            );
          }

          try {
            // PHASE 6: LOCALSTORAGE OPERATIONS
            if ($DebugTestMode) {
              console.log("üéØ === PHASE 6: LOCALSTORAGE OPERATIONS ===");
            }

            // Primary storage
            if ($DebugTestMode) {
              console.log("üéØ Storing with primary key: ai_restore_request");
            }
            localStorage.setItem(
              "ai_restore_request",
              JSON.stringify(messageData)
            );

            // Verify primary storage
            const storedPrimary = localStorage.getItem("ai_restore_request");
            if ($DebugTestMode) {
              console.log(
                "üéØ Primary storage verification:",
                storedPrimary ? "SUCCESS" : "FAILED"
              );
              if (storedPrimary) {
                try {
                  const parsed = JSON.parse(storedPrimary);
                  console.log(
                    "üéØ Primary storage parsed successfully:",
                    parsed.restoreId === restoreId ? "ID MATCH" : "ID MISMATCH"
                  );
                } catch (e) {
                  console.error("‚ùå Primary storage parse failed:", e);
                }
              }
            }

            // Backup storage keys
            const backupKeys = [
              "restore_ai",
              "show_ai_window",
              "ai_command",
              "control_restore_command",
              "window_restore_ai",
              "ai_restore_message",
            ];

            if ($DebugTestMode) {
              console.log("üéØ Storing with backup keys:", backupKeys);
            }
            backupKeys.forEach((key, index) => {
              if ($DebugTestMode) {
                console.log(
                  `üéØ [${index + 1}/${
                    backupKeys.length
                  }] Storing with key: ${key}`
                );
              }
              localStorage.setItem(key, JSON.stringify(messageData));

              // Immediate verification
              const stored = localStorage.getItem(key);
              if ($DebugTestMode) {
                console.log(
                  `üéØ [${index + 1}/${backupKeys.length}] Verification: ${
                    stored ? "SUCCESS" : "FAILED"
                  }`
                );
              }
            });

            // PHASE 7: MULTI-CHANNEL COMMUNICATION
            if ($DebugTestMode) {
              console.log("üéØ === PHASE 7: MULTI-CHANNEL COMMUNICATION ===");
            }

            // Method 1: PostMessage
            if ($DebugTestMode) {
              console.log("üéØ [COMM 1/4] PostMessage to parent...");
            }
            if (window.parent !== window) {
              if ($DebugTestMode) {
                console.log(
                  "üéØ [COMM 1/4] Parent window detected, sending message"
                );
              }
              window.parent.postMessage(messageData, "*");
              if ($DebugTestMode) {
                console.log("üéØ [COMM 1/4] PostMessage sent successfully");
              }
            } else {
              if ($DebugTestMode) {
                console.log(
                  "üéØ [COMM 1/4] No parent window, skipping postMessage"
                );
              }
            }

            // Method 2: Custom Events
            if ($DebugTestMode) {
              console.log("üéØ [COMM 2/4] Custom events...");
            }
            const customEvents = [
              "controlRestoreAI",
              "restoreAI",
              "aiRestore",
              "showAI",
            ];

            customEvents.forEach((eventName, index) => {
              if ($DebugTestMode) {
                console.log(
                  `üéØ [COMM 2/4] [${index + 1}/${
                    customEvents.length
                  }] Dispatching: ${eventName}`
                );
              }
              window.dispatchEvent(
                new CustomEvent(eventName, { detail: messageData })
              );
              if ($DebugTestMode) {
                console.log(
                  `üéØ [COMM 2/4] [${index + 1}/${
                    customEvents.length
                  }] Event dispatched successfully`
                );
              }
            });

            // Method 3: Electron API
            if ($DebugTestMode) {
              console.log("üéØ [COMM 3/4] Electron API...");
            }
            if (window.electronAPI) {
              if ($DebugTestMode) {
                console.log("üéØ [COMM 3/4] Electron API detected");
              }

              if (window.electronAPI.restoreAIWindow) {
                if ($DebugTestMode) {
                  console.log(
                    "üéØ [COMM 3/4] Calling electronAPI.restoreAIWindow()"
                  );
                }
                try {
                  const result = window.electronAPI.restoreAIWindow();
                  if ($DebugTestMode) {
                    console.log("üéØ [COMM 3/4] Electron API result:", result);
                  }
                } catch (apiError) {
                  if ($DebugTestMode) {
                    console.error(
                      "‚ùå [COMM 3/4] Electron API error:",
                      apiError
                    );
                  }
                }
              } else {
                if ($DebugTestMode) {
                  console.log(
                    "üéØ [COMM 3/4] restoreAIWindow method not available"
                  );
                }
              }
            } else {
              if ($DebugTestMode) {
                console.log("üéØ [COMM 3/4] Electron API not available");
              }
            }

            // Method 4: Force check trigger
            if ($DebugTestMode) {
              console.log("üéØ [COMM 4/4] Force check trigger...");
            }
            const forceCheckValue = Date.now().toString();
            localStorage.setItem("force_control_check", forceCheckValue);
            if ($DebugTestMode) {
              console.log("üéØ [COMM 4/4] Force check set:", forceCheckValue);
            }

            // PHASE 8: CLEANUP SCHEDULING
            if ($DebugTestMode) {
              console.log("üéØ === PHASE 8: CLEANUP SCHEDULING ===");
              console.log("üéØ Setting cleanup timer for 3 seconds...");
            }

            setTimeout(() => {
              if ($DebugTestMode) {
                console.log("üéØ üßπ === CLEANUP PHASE START ===");
                console.log(
                  "üéØ üßπ Cleanup timer triggered at:",
                  new Date().toISOString()
                );
              }

              const cleanupKeys = [
                "ai_restore_request",
                ...backupKeys,
                "force_control_check",
              ];

              cleanupKeys.forEach((key, index) => {
                const beforeValue = localStorage.getItem(key);
                if ($DebugTestMode) {
                  console.log(
                    `üéØ üßπ [${index + 1}/${
                      cleanupKeys.length
                    }] Removing ${key}:`,
                    beforeValue ? "EXISTS" : "NOT_FOUND"
                  );
                }

                if (beforeValue) {
                  localStorage.removeItem(key);
                  const afterValue = localStorage.getItem(key);
                  if ($DebugTestMode) {
                    console.log(
                      `üéØ üßπ [${index + 1}/${
                        cleanupKeys.length
                      }] Removal result:`,
                      afterValue ? "FAILED" : "SUCCESS"
                    );
                  }
                }
              });

              if ($DebugTestMode) {
                console.log("üéØ üßπ === CLEANUP PHASE COMPLETE ===");
              }
            }, 3000);
          } catch (error) {
            if ($DebugTestMode) {
              console.error("‚ùå === CRITICAL ERROR IN RESTORE AI ===");
              console.error("‚ùå Error message:", error.message);
              console.error("‚ùå Error stack:", error.stack);
              console.error("‚ùå Error at timestamp:", new Date().toISOString());
            }

            // Error recovery
            if ($DebugTestMode) {
              console.log("üéØ üÜò === ERROR RECOVERY START ===");
              console.log("üéØ üÜò Restoring button visibility...");
            }

            if (aiBtn) {
              aiBtn.style.display = "block";
              aiBtn.classList.add("show", "has-notification");
              if ($DebugTestMode) {
                console.log("üéØ üÜò Button restored");
              }
            }

            this.aiMinimized = true;
            if ($DebugTestMode) {
              console.log("üéØ üÜò aiMinimized reset to true");
              console.log("üéØ üÜò === ERROR RECOVERY COMPLETE ===");
            }
          }

          // PHASE 9: LOCALSTORAGE FLAGS CLEANUP
          if ($DebugTestMode) {
            console.log("üéØ === PHASE 9: LOCALSTORAGE FLAGS CLEANUP ===");
            console.log("üéØ Flags BEFORE cleanup:");
            console.log(
              "üéØ   control_ai_minimized:",
              localStorage.getItem("control_ai_minimized")
            );
            console.log(
              "üéØ   ai_minimized:",
              localStorage.getItem("ai_minimized")
            );
          }

          if ($DebugTestMode) {
            console.log(
              "üö®‚úÖüö®‚úÖüö®‚úÖüö®‚úÖ ALERT: CONTROL_AI_MINIMIZED HAS BEEN RESET!"
            );
          }
          localStorage.removeItem("control_ai_minimized");
          localStorage.removeItem("ai_minimized");

          if ($DebugTestMode) {
            console.log("üéØ Flags AFTER cleanup:");
            console.log(
              "üéØ   control_ai_minimized:",
              localStorage.getItem("control_ai_minimized")
            );
            console.log(
              "üéØ   ai_minimized:",
              localStorage.getItem("ai_minimized")
            );
          }

          // PHASE 10: HEARTBEAT SETTING
          if ($DebugTestMode) {
            console.log("üéØ === PHASE 10: HEARTBEAT SETTING ===");
          }
          const heartbeatValue = Date.now().toString();
          localStorage.setItem("ai_heartbeat", heartbeatValue);
          if ($DebugTestMode) {
            console.log("üéØ Fresh AI heartbeat set:", heartbeatValue);
          }

          // Verify heartbeat
          const verifyHeartbeat = localStorage.getItem("ai_heartbeat");
          if ($DebugTestMode) {
            console.log(
              "üéØ Heartbeat verification:",
              verifyHeartbeat === heartbeatValue ? "SUCCESS" : "FAILED"
            );
          }

          // FINAL PHASE: COMPLETION LOG
          if ($DebugTestMode) {
            console.log("üéØ === FINAL PHASE: COMPLETION SUMMARY ===");
            console.log(
              "üéØ Function completion timestamp:",
              new Date().toISOString()
            );
            console.log(
              "üéØ Total execution time:",
              Date.now() - messageData.timestamp,
              "ms"
            );
            console.log("üéØ Final state summary:");
            console.log("üéØ   aiMinimized:", this.aiMinimized);
            console.log("üéØ   aiRestoring:", this.aiRestoring);
            console.log("üéØ   currentRestoreId:", this.currentRestoreId);
            console.log(
              "üéØ   Button hidden:",
              aiBtn ? aiBtn.style.display === "none" : "BUTTON_NOT_FOUND"
            );
            console.log("üéØ   Restore attempts:", this.restoreAttempts);
            console.log("üéØüéØüéØ === ULTRA-ENHANCED AI RESTORE COMPLETE ===");
          }
        }

        getTranscriptWords() {
          return new Promise((resolve, reject) => {
            if ($DebugTestMode) {
              console.log("Starting getTranscriptWords() function");
            }

            // First try to use IPC to get transcript words
            if (
              window.electronAPI &&
              typeof window.electronAPI.getTranscriptWords
            ) {
              if ($DebugTestMode) {
                console.log("Electron API detected, using IPC method");
                console.log("Calling window.electronAPI.getTranscriptWords()");
              }

              window.electronAPI
                .getTranscriptWords()
                .then((response) => {
                  if ($DebugTestMode) {
                    console.log(
                      "IPC call successful, received response:",
                      response
                    );
                  }

                  // Extract the words from the response object
                  const transcriptWords = response.words;
                  if ($DebugTestMode) {
                    console.log(
                      `Received ${transcriptWords.length} transcript words`
                    );
                  }

                  if (transcriptWords.length > 0) {
                    if ($DebugTestMode) {
                      console.log("Sending words to AI window");
                    }
                    this.sendWordsToAIWindow(transcriptWords);
                  } else {
                    if ($DebugTestMode) {
                      console.warn("No words received or empty array from IPC");
                    }
                  }

                  resolve(transcriptWords);
                })
                .catch((error) => {
                  if ($DebugTestMode) {
                    console.error("IPC failed with error:", error);
                    console.error("Error details:", error.message, error.stack);
                  }
                  reject(error);
                });
            } else {
              // IPC not available, use DOM extraction
              if ($DebugTestMode) {
                console.error(
                  "IPC renderer not available - electronAPI not found or invoke method missing"
                );
                console.warn("Falling back to DOM extraction method");
              }
              resolve([]); // Resolve with empty array to handle fallback gracefully
            }
          });
        }
        // Function to send words to AI window
        sendWordsToAIWindow(words) {
          return new Promise((resolve, reject) => {
            // First try to use IPC to get transcript words
            if (
              window.electronAPI &&
              typeof window.electronAPI.sendWordsToAIWindow === "function"
            ) {
              if ($DebugTestMode) {
                console.log("Electron API detected, using IPC method");
                console.log(
                  "Calling window.electronAPI.sendWordsToAIWindow(words)"
                );
              }

              window.electronAPI
                .sendWordsToAIWindow(words)
                .then(() => {
                  resolve();
                })
                .catch((error) => {
                  if ($DebugTestMode) {
                    console.error("IPC failed with error:", error);
                    console.error("Error details:", error.message, error.stack);
                  }
                  reject(error);
                });
            } else {
              // IPC not available, use DOM extraction
              if ($DebugTestMode) {
                console.error(
                  "IPC renderer not available - electronAPI not found or invoke method missing"
                );
                console.warn("Falling back to DOM extraction method");
              }
              reject(new Error("IPC renderer not available"));
            }
          });
        }
        /*restoreTranscript() {
          if ($DebugTestMode) {
            console.log(
              "üîÑ ========== TRANSCRIPT RESTORE DEBUG START =========="
            );
            console.log(
              "üîÑ CONTROL: restoreTranscript() called at:",
              new Date().toISOString()
            );
            console.log(
              "üîÑ CONTROL: Current transcriptMinimized state:",
              this.transcriptMinimized
            );
            console.log(
              "üîÑ CONTROL: Current localStorage flags before restore:"
            );
            console.log(
              "  - control_transcript_minimized:",
              localStorage.getItem("control_transcript_minimized")
            );
            console.log(
              "  - transcript_minimized:",
              localStorage.getItem("transcript_minimized")
            );
            console.log(
              "  - transcript_heartbeat:",
              localStorage.getItem("transcript_heartbeat")
            );
            console.log(
              "  - transcript_restore_request:",
              localStorage.getItem("transcript_restore_request")
            );
            console.log("üîÑ CONTROL: Current sessionStorage flags:");
            console.log(
              "  - transcript_minimized_this_session:",
              sessionStorage.getItem("transcript_minimized_this_session")
            );
          }

          // üîß NEW: IMMEDIATELY hide the button when clicked
          if ($DebugTestMode) {
            console.log("üîÑ CONTROL: Calling hideTranscriptButton()...");
          }
          this.hideTranscriptButton();

          // üîß NEW: Update internal state immediately
          const previousState = this.transcriptMinimized;
          this.transcriptMinimized = false;

          if ($DebugTestMode) {
            console.log(
              "üîÑ CONTROL: Updated internal state - transcriptMinimized:",
              previousState,
              "‚Üí",
              this.transcriptMinimized
            );
          }

          try {
            const messageData = {
              type: "RESTORE_TRANSCRIPT",
              timestamp: Date.now(),
              source: "control",
              restoreId: Date.now() + Math.random().toString(36).substr(2, 5),
            };

            if ($DebugTestMode) {
              console.log("üîÑ CONTROL: Created restore message:", messageData);
              console.log("üîÑ CONTROL: Storing message in localStorage...");
            }

            localStorage.setItem(
              "transcript_restore_request",
              JSON.stringify(messageData)
            );

            // Verify storage
            const storedMessage = localStorage.getItem(
              "transcript_restore_request"
            );
            if ($DebugTestMode) {
              console.log(
                "üîÑ CONTROL: Verification - stored message:",
                storedMessage ? "SUCCESS" : "FAILED"
              );
              if (storedMessage) {
                console.log(
                  "üîÑ CONTROL: Stored message content:",
                  JSON.parse(storedMessage)
                );
              }
            }

            // Additional message sending methods
            if ($DebugTestMode) {
              console.log(
                "üîÑ CONTROL: Sending restore message via multiple channels..."
              );
            }

            if (window.parent !== window) {
              if ($DebugTestMode) {
                console.log("üîÑ CONTROL: Sending postMessage to parent...");
              }
              window.parent.postMessage(messageData, "*");
            }

            if ($DebugTestMode) {
              console.log("üîÑ CONTROL: Dispatching custom event...");
            }
            window.dispatchEvent(
              new CustomEvent("controlRestoreTranscript", {
                detail: messageData,
              })
            );

            if (
              window.electronAPI &&
              window.electronAPI.restoreTranscriptWindow
            ) {
              if ($DebugTestMode) {
                console.log(
                  "üîÑ CONTROL: Calling electronAPI.restoreTranscriptWindow()..."
                );
              }
              const result = window.electronAPI.restoreTranscriptWindow();
              if ($DebugTestMode) {
                console.log("üîÑ CONTROL: Electron API result:", result);
              }
            } else {
              if ($DebugTestMode) {
                console.log("üîÑ CONTROL: Electron API not available");
              }
            }

            if ($DebugTestMode) {
              console.log("üîÑ CONTROL: Setting cleanup timer for 3 seconds...");
            }
            setTimeout(() => {
              localStorage.removeItem("transcript_restore_request");
              if ($DebugTestMode) {
                console.log(
                  "üîÑ CONTROL: Cleanup - removed transcript_restore_request"
                );
              }
            }, 3000);
          } catch (error) {
            if ($DebugTestMode) {
              console.error(
                "üîÑ CONTROL: ‚ùå ERROR in restoreTranscript():",
                error
              );
              console.error("üîÑ CONTROL: Error stack:", error.stack);
            }
          }

          // üîß NEW: Clear localStorage flags immediately
          if ($DebugTestMode) {
            console.log(
              "üîÑ CONTROL: Clearing localStorage flags immediately..."
            );
            console.log(
              "üîÑ CONTROL: Before clearing - control_transcript_minimized:",
              localStorage.getItem("control_transcript_minimized")
            );
          }

          if ($DebugTestMode) {
            console.log(
              "üö®üö®üö®üö®üö® ALERT: CONTROL_TRANSCRIPT_MINIMIZED HAS BEEN RESET!"
            );
          }
          localStorage.removeItem("control_transcript_minimized");
          localStorage.removeItem("control_transcript_minimized_time");
          localStorage.removeItem("transcript_minimized");

          if ($DebugTestMode) {
            console.log(
              "üîÑ CONTROL: After clearing - control_transcript_minimized:",
              localStorage.getItem("control_transcript_minimized")
            );
            console.log(
              "üîÑ CONTROL: After clearing - transcript_minimized:",
              localStorage.getItem("transcript_minimized")
            );
          }

          // üîß NEW: Set fresh heartbeat to indicate transcript is active
          const heartbeatValue = Date.now().toString();
          localStorage.setItem("transcript_heartbeat", heartbeatValue);

          if ($DebugTestMode) {
            console.log("üîÑ CONTROL: Set fresh heartbeat:", heartbeatValue);
            console.log(
              "üîÑ CONTROL: Transcript button hidden immediately on click"
            );
            console.log(
              "üîÑ ========== TRANSCRIPT RESTORE DEBUG END =========="
            );
          }
        }*/
        setupKeepAlive() {
          this.keepAliveInterval = setInterval(() => {
            this.sendHeartbeat();
            this.checkWindowVisibility();
          }, 30000);

          window.addEventListener("focus", () => {
            this.ensureWindowVisibility();
          });

          window.addEventListener("blur", () => {
            setTimeout(() => {
              this.ensureWindowVisibility();
            }, 100);
          });
        }

        sendHeartbeat() {
          // Only send CONTROL heartbeat, not transcript heartbeat
          localStorage.setItem("control_heartbeat", Date.now().toString());

          if (window.electronAPI && window.electronAPI.sendHeartbeat) {
            window.electronAPI.sendHeartbeat();
          }

          if ($DebugTestMode) {
            console.log("Heartbeat sent at", new Date().toLocaleTimeString());
            console.log("Window visibility checked");
          }
        }

        checkWindowVisibility() {
          const body = document.body;
          if (body) {
            body.style.display = "flex";
            body.style.opacity = "1";
            body.style.visibility = "visible";
            body.style.transform = "none";
            body.style.position = "relative";
          }

          if (window.electronAPI && window.electronAPI.ensureWindowVisible) {
            window.electronAPI.ensureWindowVisible();
          }

          if ($DebugTestMode) {
            console.log("Window visibility checked");
          }
        }

        ensureWindowVisibility() {
          const body = document.body;
          if (body) {
            body.style.display = "flex";
            body.style.opacity = "1";
            body.style.visibility = "visible";
            body.style.pointerEvents = "auto";
          }

          if (window.electronAPI && window.electronAPI.bringToFront) {
            window.electronAPI.bringToFront();
          }

          if ($DebugTestMode) {
            console.log("Window visibility ensured");
          }
        }

        logWindowState() {
          const body = document.body;
          const state = {
            display: body.style.display || getComputedStyle(body).display,
            opacity: body.style.opacity || getComputedStyle(body).opacity,
            visibility:
              body.style.visibility || getComputedStyle(body).visibility,
            classList: Array.from(body.classList),
            windowLocation: { x: window.screenX, y: window.screenY },
            windowSize: {
              width: window.innerWidth,
              height: window.innerHeight,
            },
            lastActivity: new Date(this.lastActivity).toLocaleTimeString(),
            isListening: this.isListening,
            transcriptMinimized: this.transcriptMinimized,
            aiMinimized: this.aiMinimized,
            aiRestoring: this.aiRestoring,
            currentRestoreId: this.currentRestoreId,
            restoreAttempts: this.restoreAttempts,
            messageLogLength: this.messageLog.length,
          };

          if ($DebugTestMode) {
            console.log("Window state:", state);
          }
        }

        setupEventListeners() {
          document.addEventListener("contextmenu", (e) => {
            if (e.target.closest(".container")) {
              e.preventDefault();
              this.toggleSettingsMenu();
            }
          });

          document.addEventListener("click", (e) => {
            if (!e.target.closest(".container")) {
              this.hideSettingsMenu();
            }
          });
        }

        setupKeyboardShortcuts() {
          document.addEventListener("keydown", (e) => {
            this.lastActivity = Date.now();

            if (e.code === "Space" && !e.ctrlKey && !e.altKey && !e.shiftKey) {
              e.preventDefault();
              this.toggleListening();
            }

            if (e.code === "KeyT" && !e.ctrlKey && !e.altKey && !e.shiftKey) {
              e.preventDefault();
              if (this.transcriptMinimized) {
                this.restoreTranscript();
              }
            }

            if (e.code === "KeyA" && !e.ctrlKey && !e.altKey && !e.shiftKey) {
              e.preventDefault();
              if (this.aiMinimized) {
                this.restoreAI();
              }
            }

            if (e.code === "KeyS" && !e.ctrlKey && !e.altKey && !e.shiftKey) {
              e.preventDefault();
              this.openSettings();
            }

            if (e.code === "Enter" && e.ctrlKey) {
              e.preventDefault();
              this.captureScreenshot();
            }

            if (e.code === "KeyS" && e.ctrlKey) {
              e.preventDefault();
              this.openSettings();
            }

            if (e.code === "Escape") {
              this.hideSettingsMenu();
              this.hideShortcutsHint();
            }

            if (e.code === "KeyP" && e.ctrlKey && e.shiftKey) {
              e.preventDefault();
              this.testAIConnection();
            }

            if (e.code === "KeyR" && e.ctrlKey && e.shiftKey) {
              e.preventDefault();
              this.restoreAI();
            }

            if (e.code === "KeyC" && e.ctrlKey && e.shiftKey) {
              e.preventDefault();
              this.cleanupRestoreMessages();
            }
          });
        }

        setupTooltips() {
          const buttons = document.querySelectorAll(".btn, .close-btn");
          buttons.forEach((btn) => {
            btn.addEventListener("mouseenter", (e) => {
              const tooltip = e.target.title;
              if (tooltip) {
                this.showTooltip(tooltip);
              }
            });

            btn.addEventListener("mouseleave", () => {
              this.hideTooltip();
            });
          });
        }

        setupActivityDetection() {
          ["mousedown", "mousemove", "keydown", "click", "touchstart"].forEach(
            (event) => {
              document.addEventListener(event, () => {
                this.handleActivity();
              });
            }
          );

          this.handleActivity();
        }

        handleActivity() {
          this.lastActivity = Date.now();

          document.body.classList.remove("inactive-mode");
          document.body.classList.add("fade-mode");

          if (this.fadeTimer) {
            clearTimeout(this.fadeTimer);
          }

          // üîß NEW: CRITICAL FIX - Don't fade out while listening
          if (!isListening) {
            this.fadeTimer = setTimeout(() => {
              document.body.classList.remove("fade-mode");
              document.body.classList.add("inactive-mode");
              this.ensureWindowVisibility();
            }, 10000);
          } else {
            // üîß NEW: If listening, keep window visible
            this.ensureWindowVisibility();
          }
        }

        toggleListening() {
          if ($DebugTestMode) {
            console.log("üéØ === NATIVE AUDIO toggleListening ===");
            console.log("üéØ Current state:", this.isListening);
            console.log("üîß LanguageTool ready:", this.languageToolReady);
          }

          // üîß FIX: Don't change this.isListening here - let main renderer handle it
          const targetState = !this.isListening;

          const btn = document.getElementById("listenBtn");
          const statusDot = document.getElementById("statusDot");
          const statusText = document.getElementById("statusText");

          if (targetState) {
            // About to start listening - show transitioning state only
            if ($DebugTestMode) {
              console.log("‚ñ∂Ô∏è Starting NATIVE audio listening mode...");
            }
            btn.textContent = "Starting Native...";
            statusText.textContent = "Starting Native Audio...";
          } else {
            // About to stop listening - show transitioning state only
            if ($DebugTestMode) {
              console.log("‚è∏Ô∏è Stopping NATIVE audio listening mode...");
            }
            btn.textContent = "Stopping...";
            statusText.textContent = "Stopping...";
          }

          // Call main renderer - it will handle the actual state change
          if (window.toggleListeningMain) {
            window.toggleListeningMain();
          }

          if ($DebugTestMode) {
            console.log("NATIVE audio listening toggled:", this.isListening);
          }
        }

        captureScreenshot() {
          if (window.electronAPI) {
            window.electronAPI
              .captureScreenshot()
              .then((screenshot) => {
                if (screenshot) {
                  // Instead of directly processing, add to chat input as preview
                  this.addScreenshotToChat(screenshot);
                } else {
                  if ($DebugTestMode) {
                    console.log("No screenshot captured");
                  }
                }
              })
              .catch((error) => {
                if ($DebugTestMode) {
                  console.log("Screenshot error:", error);
                }
              });
          }
        }

        addScreenshotToChat(screenshot) {
          if ($DebugTestMode) {
            console.log("üì∏ Adding screenshot to chat input...");
            console.log("üì∏ Screenshot type:", typeof screenshot);
            console.log("üì∏ Screenshot length:", screenshot?.length);
            console.log("üì∏ Screenshot sample:", screenshot?.substring(0, 50));
          }

          try {
            // VALIDATE SCREENSHOT DATA
            if (!screenshot || typeof screenshot !== "string") {
              if ($DebugTestMode) {
                console.error("üì∏ Invalid screenshot data type");
              }
              return;
            }

            if (screenshot.length === 0) {
              if ($DebugTestMode) {
                console.error("üì∏ Empty screenshot data");
              }
              return;
            }

            // CHECK SIZE LIMITS
            if (screenshot.length > 10000000) {
              // 10MB limit
              if ($DebugTestMode) {
                console.error("üì∏ Screenshot too large:", screenshot.length);
              }
              return;
            }

            // Create screenshot attachment data
            const screenshotAttachment = {
              type: "image",
              filename: `screenshot_${new Date()
                .toISOString()
                .slice(0, 19)
                .replace(/:/g, "-")}.png`,
              data: screenshot,
              size: screenshot.length,
              timestamp: Date.now(),
            };

            // TEST SERIALIZATION
            const testSerialized = JSON.stringify(screenshotAttachment);
            const testParsed = JSON.parse(testSerialized);
            if (testParsed.data !== screenshot) {
              if ($DebugTestMode) {
                console.error("üì∏ Data corruption during serialization");
              }
              return;
            }
            if ($DebugTestMode) {
              console.log("üì∏ ‚úÖ Serialization test passed");
            }

            // Send message to AI window to add screenshot to input
            const message = {
              type: "ADD_SCREENSHOT_ATTACHMENT",
              attachment: screenshotAttachment,
              timestamp: Date.now(),
              source: "control",
            };

            // Store in localStorage for AI window to pick up
            localStorage.setItem(
              "screenshot_attachment",
              JSON.stringify(message)
            );

            // Try postMessage as well
            if (window.parent !== window) {
              window.parent.postMessage(message, "*");
            }

            // Dispatch custom event
            window.dispatchEvent(
              new CustomEvent("screenshotCaptured", {
                detail: message,
              })
            );

            if ($DebugTestMode) {
              console.log("üì∏ Screenshot attachment sent to AI window");
            }
          } catch (error) {
            if ($DebugTestMode) {
              console.error("‚ùå Error adding screenshot to chat:", error);
            }
          }
        }

        async openSettings() {
          if ($DebugTestMode) {
            console.log("üîß Opening settings in default browser...");
          }

          const settingsUrl =
            "http://localhost/Memoria/public/html/Micro_Learner.html";

          try {
            // Method 1: Use the new IPC handler (preferred)
            if (window.electronAPI?.openExternalUrl) {
              if ($DebugTestMode) {
                console.log("üîß Method 1: Using IPC openExternalUrl");
              }

              const result = await window.electronAPI.openExternalUrl(
                settingsUrl
              );

              if (result.success) {
                if ($DebugTestMode) {
                  console.log("üîß ‚úÖ Settings opened successfully via IPC");
                }
                return;
              } else {
                if ($DebugTestMode) {
                  console.error("üîß ‚ùå IPC method failed:", result.error);
                }
              }
            }
          } catch (error) {
            if ($DebugTestMode) {
              console.error("üîß ‚ùå IPC method failed:", error);
            }
          }

          // Method 2: Fallback to window.open
          try {
            if ($DebugTestMode) {
              console.log("üîß Method 2: Using window.open fallback");
            }

            window.open(settingsUrl, "_blank");

            if ($DebugTestMode) {
              console.log("üîß ‚úÖ Settings opened via window.open");
            }
          } catch (error) {
            if ($DebugTestMode) {
              console.error("üîß ‚ùå All methods failed:", error);
            }
          }
        }

        showTooltip(text) {
          const tooltip = document.getElementById("tooltip");
          if (tooltip) {
            tooltip.textContent = text;
            tooltip.classList.add("show");
          }
        }

        hideTooltip() {
          const tooltip = document.getElementById("tooltip");
          if (tooltip) {
            tooltip.classList.remove("show");
          }
        }

        toggleSettingsMenu() {
          const menu = document.getElementById("settingsMenu");
          if (menu) {
            menu.classList.toggle("show");
          }
        }

        hideSettingsMenu() {
          const menu = document.getElementById("settingsMenu");
          if (menu) {
            menu.classList.remove("show");
          }
        }

        hideShortcutsHint() {
          const hint = document.getElementById("shortcutsHint");
          if (hint) {
            hint.classList.remove("show");
          }
        }

        closeAll() {
          if (window.electronAPI && window.electronAPI.closeAll) {
            window.electronAPI.closeAll();
          }
        }

        checkAuth() {
          const token = localStorage.getItem("memoria_token");
          const userData = localStorage.getItem("memoria_user");

          if (token && userData) {
            try {
              this.authState = {
                isAuthenticated: true,
                token: token,
                user: JSON.parse(userData),
              };
              //this.updateAuthStatus();
            } catch (error) {
              if ($DebugTestMode) {
                console.log("Failed to parse auth data:", error);
              }
            }
          }

          setTimeout(() => {
            this.checkAuth();
          }, 2000);
        }

        /* updateAuthStatus() {
          const statusDot = document.getElementById("statusDot");
          //const statusText = document.getElementById("statusText");

          // ‚úÖ ADDED CHECK: Ensure user and user.email exist and email is a string
          if (
            this.authState.isAuthenticated &&
            this.authState.user &&
            typeof this.authState.user.email === "string"
          ) {
            statusDot.classList.add("auth");
            statusText.textContent = `Ready - ${
              this.authState.user.email.split("@")[0]
            }`;
          } else {
            statusDot.classList.remove("auth");
            //statusText.textContent = "Ready - Free version";
          }
        }*/

        restoreSettings() {
          try {
            const settings = localStorage.getItem("control_settings");
            if (settings) {
              const parsed = JSON.parse(settings);
              // Apply settings...
            }
          } catch (error) {
            if ($DebugTestMode) {
              console.log("Failed to restore settings:", error);
            }
          }
        }

        saveSettings() {
          const settings = {
            transcriptMinimized: this.transcriptMinimized,
            aiMinimized: this.aiMinimized,
            aiRestoring: this.aiRestoring,
            timestamp: Date.now(),
          };

          localStorage.setItem("control_settings", JSON.stringify(settings));
        }

        destroy() {
          if (this.keepAliveInterval) {
            clearInterval(this.keepAliveInterval);
          }
          if (this.fadeTimer) {
            clearTimeout(this.fadeTimer);
          }
          if (this.storageWatcher) {
            clearInterval(this.storageWatcher);
          }

          // NEW: Clean up window size listener
          if (
            this.windowSizeListenerSet &&
            window.electronAPI?.removeWindowSizeListener
          ) {
            window.electronAPI.removeWindowSizeListener();
          }
        }

        // üîß NEW: Setup LanguageTool monitoring
        setupLanguageToolMonitoring() {
          if ($DebugTestMode) {
            console.log("üîß Setting up LanguageTool monitoring...");
          }

          // Listen for LanguageTool progress
          if (window.electronAPI?.onLanguageToolProgress) {
            window.electronAPI.onLanguageToolProgress((progress) => {
              if ($DebugTestMode) {
                console.log("üìä LanguageTool progress:", progress);
              }
            });
          }

          // Listen for LanguageTool ready
          if (window.electronAPI?.onLanguageToolReady) {
            window.electronAPI.onLanguageToolReady((status) => {
              if ($DebugTestMode) {
                console.log("‚úÖ LanguageTool ready:", status);
              }
              this.languageToolReady = true;
            });
          }

          // Listen for LanguageTool errors
          if (window.electronAPI?.onLanguageToolError) {
            window.electronAPI.onLanguageToolError((error) => {
              if ($DebugTestMode) {
                console.error("‚ùå LanguageTool error:", error);
              }
            });
          }

          // Listen for LanguageTool installation complete
          if (window.electronAPI?.onLanguageToolInstalled) {
            window.electronAPI.onLanguageToolInstalled((status) => {
              if ($DebugTestMode) {
                console.log("‚úÖ LanguageTool installed:", status);
              }
              this.languageToolInstalled = true;
            });
          }

          // Check initial status
          this.checkInitialLanguageToolStatus();
        }

        // üîß NEW: Check initial LanguageTool status
        async checkInitialLanguageToolStatus() {
          if (window.electronAPI?.getLanguageToolStatus) {
            try {
              const status = await window.electronAPI.getLanguageToolStatus();
              if ($DebugTestMode) {
                console.log("üîç Initial LanguageTool status:", status);
              }
            } catch (error) {
              if ($DebugTestMode) {
                console.error(
                  "Failed to get initial LanguageTool status:",
                  error
                );
              }
            }
          }
        }
      }

      function toggleListening() {
        if ($DebugTestMode) {
          console.log("üéØ === FIXED TOGGLE LISTENING ===");
          console.log("üéØ Current state:", isListening);
        }

        const btn = document.getElementById("listenBtn");

        // Disable button during transition
        if (btn) {
          btn.disabled = true;
        }

        try {
          if (
            window.toggleListeningMain &&
            typeof window.toggleListeningMain === "function"
          ) {
            window.toggleListeningMain();

            // Re-enable button after delay
            setTimeout(() => {
              if (btn) btn.disabled = false;
            }, 1000);
          } else {
            if ($DebugTestMode) {
              console.error("‚ùå Main renderer not available");
            }
            if (btn) {
              btn.textContent = "Error";
              btn.disabled = false;
            }
          }
        } catch (error) {
          if ($DebugTestMode) {
            console.error("‚ùå Error:", error);
          }
          if (btn) {
            btn.textContent = isListening ? "‚è∏ Stop" : "‚ñ∂ Listen";
            btn.disabled = false;
          }
        }
      }
      /*
      function restoreTranscript() {
        if ($DebugTestMode) {
          console.log("üéØ restoreTranscript global function called");
        }
        if (window.controlManager) {
          window.controlManager.restoreTranscript();
        } else {
          if ($DebugTestMode) {
            console.error("‚ùå controlManager not available");
          }
        }
      }
*/
      // ULTRA-ENHANCED global restoreAI function with even more debugging
      function restoreAI() {
        if ($DebugTestMode) {
          console.log("üåçüåçüåç === ULTRA-ENHANCED GLOBAL RESTORE AI CALLED ===");
          console.log(
            "üåç Global function entry timestamp:",
            new Date().toISOString()
          );
          console.log("üåç User clicked the AI restore button");
          console.log("üåç Call stack:", new Error().stack);
        }

        // PHASE 1: MANAGER AVAILABILITY CHECK
        if ($DebugTestMode) {
          console.log("üåç === PHASE 1: MANAGER AVAILABILITY CHECK ===");
          console.log(
            "üåç window object exists:",
            typeof window !== "undefined"
          );
          console.log(
            "üåç window.controlManager exists:",
            typeof window.controlManager !== "undefined"
          );
          console.log(
            "üåç window.controlManager type:",
            typeof window.controlManager
          );
        }

        if (!window.controlManager) {
          if ($DebugTestMode) {
            console.error("‚ùå === CRITICAL: CONTROL MANAGER NOT AVAILABLE ===");
            console.error("‚ùå window object:", typeof window);
            console.error("‚ùå window.controlManager:", window.controlManager);
            console.error(
              "‚ùå Available window properties:",
              Object.keys(window).filter((k) => k.includes("control"))
            );
          }

          // FALLBACK MECHANISM
          if ($DebugTestMode) {
            console.log("üÜò === FALLBACK MECHANISM ACTIVATED ===");
            console.log("üÜò Creating fallback restore message...");
          }
          try {
            const fallbackMessage = {
              type: "AI_RESTORE_REQUEST_FALLBACK",
              timestamp: Date.now(),
              source: "control_fallback",
              fallbackReason: "controlManager_not_available",
              userAgent: navigator.userAgent,
              url: window.location.href,
            };

            if ($DebugTestMode) {
              console.log("üÜò Fallback message created:", fallbackMessage);
            }

            // Multiple fallback storage attempts
            const fallbackKeys = [
              "ai_restore_fallback",
              "emergency_ai_restore",
              "backup_restore_ai",
              "fallback_ai_command",
            ];

            fallbackKeys.forEach((key, index) => {
              if ($DebugTestMode) {
                console.log(
                  `üÜò [${index + 1}/${
                    fallbackKeys.length
                  }] Storing fallback with key: ${key}`
                );
              }
              localStorage.setItem(key, JSON.stringify(fallbackMessage));

              const verification = localStorage.getItem(key);
              if ($DebugTestMode) {
                console.log(
                  `üÜò [${index + 1}/${fallbackKeys.length}] Verification:`,
                  verification ? "SUCCESS" : "FAILED"
                );
              }
            });

            // Force check
            const forceValue = Date.now().toString();
            localStorage.setItem("force_control_check", forceValue);
            if ($DebugTestMode) {
              console.log("üÜò Force check set:", forceValue);
            }

            // Additional emergency signals
            localStorage.setItem(
              "emergency_restore_signal",
              Date.now().toString()
            );
            localStorage.setItem("ai_restore_emergency", "true");

            if ($DebugTestMode) {
              console.log("üÜò Fallback mechanism completed");
            }
          } catch (fallbackError) {
            if ($DebugTestMode) {
              console.error("‚ùå Fallback mechanism failed:", fallbackError);
              console.error("‚ùå Fallback error stack:", fallbackError.stack);
            }
          }

          if ($DebugTestMode) {
            console.log("üåç === GLOBAL FUNCTION ENDING (NO MANAGER) ===");
          }
          return;
        }

        // PHASE 2: METHOD AVAILABILITY CHECK
        if ($DebugTestMode) {
          console.log("üåç === PHASE 2: METHOD AVAILABILITY CHECK ===");
          console.log(
            "üåç controlManager.restoreAI exists:",
            typeof window.controlManager.restoreAI !== "undefined"
          );
          console.log(
            "üåç controlManager.restoreAI type:",
            typeof window.controlManager.restoreAI
          );
          console.log(
            "üåç Available controlManager methods:",
            Object.getOwnPropertyNames(window.controlManager).filter(
              (prop) => typeof window.controlManager[prop] === "function"
            )
          );
        }

        if (!window.controlManager.restoreAI) {
          if ($DebugTestMode) {
            console.error("‚ùå === CRITICAL: RESTORE AI METHOD NOT FOUND ===");
            console.error(
              "‚ùå Method type:",
              typeof window.controlManager.restoreAI
            );
            console.error(
              "‚ùå Available methods:",
              Object.keys(window.controlManager).filter(
                (k) => typeof window.controlManager[k] === "function"
              )
            );
            console.log("üåç === GLOBAL FUNCTION ENDING (NO METHOD) ===");
          }
          return;
        }

        // PHASE 3: PRE-CALL STATE LOGGING
        if ($DebugTestMode) {
          console.log("üåç === PHASE 3: PRE-CALL STATE LOGGING ===");
          console.log("üåç Manager state before call:");
          console.log("üåç   aiMinimized:", window.controlManager.aiMinimized);
          console.log("üåç   aiRestoring:", window.controlManager.aiRestoring);
          console.log(
            "üåç   currentRestoreId:",
            window.controlManager.currentRestoreId
          );
          console.log(
            "üåç   restoreAttempts:",
            window.controlManager.restoreAttempts
          );
          console.log(
            "üåç   lastRestoreTime:",
            window.controlManager.lastRestoreTime
          );

          // Check localStorage before call
          console.log("üåç LocalStorage before call:");
          console.log(
            "üåç   control_ai_minimized:",
            localStorage.getItem("control_ai_minimized")
          );
          console.log(
            "üåç   ai_minimized:",
            localStorage.getItem("ai_minimized")
          );
          console.log(
            "üåç   ai_heartbeat:",
            localStorage.getItem("ai_heartbeat")
          );
        }

        // PHASE 4: THE ACTUAL METHOD CALL
        if ($DebugTestMode) {
          console.log("üåç === PHASE 4: EXECUTING METHOD CALL ===");
          console.log("üìû About to call controlManager.restoreAI()...");
          console.log("üìû Call timestamp:", new Date().toISOString());
        }

        let callResult = null;
        let callError = null;
        const callStartTime = Date.now();

        try {
          if ($DebugTestMode) {
            console.log("üìû CALLING NOW...");
          }
          callResult = window.controlManager.restoreAI();
          if ($DebugTestMode) {
            console.log("üìû Method call completed successfully");
            console.log("üìû Call duration:", Date.now() - callStartTime, "ms");
            console.log("üìû Return value:", callResult);
            console.log("üìû Return value type:", typeof callResult);
          }
        } catch (error) {
          callError = error;
          if ($DebugTestMode) {
            console.error("‚ùå === METHOD CALL FAILED ===");
            console.error("‚ùå Error during method call:", error.message);
            console.error("‚ùå Error type:", error.constructor.name);
            console.error("‚ùå Error stack:", error.stack);
            console.error(
              "‚ùå Call duration before error:",
              Date.now() - callStartTime,
              "ms"
            );
          }
        }

        // PHASE 5: POST-CALL STATE VERIFICATION
        if ($DebugTestMode) {
          console.log("üåç === PHASE 5: POST-CALL STATE VERIFICATION ===");

          // Immediate state check
          console.log("üåç Manager state IMMEDIATELY after call:");
          console.log("üåç   aiMinimized:", window.controlManager.aiMinimized);
          console.log("üåç   aiRestoring:", window.controlManager.aiRestoring);
          console.log(
            "üåç   currentRestoreId:",
            window.controlManager.currentRestoreId
          );
          console.log(
            "üåç   restoreAttempts:",
            window.controlManager.restoreAttempts
          );

          // Check localStorage after call
          console.log("üåç LocalStorage IMMEDIATELY after call:");
          console.log(
            "üåç   control_ai_minimized:",
            localStorage.getItem("control_ai_minimized")
          );
          console.log(
            "üåç   ai_minimized:",
            localStorage.getItem("ai_minimized")
          );
          console.log(
            "üåç   ai_heartbeat:",
            localStorage.getItem("ai_heartbeat")
          );
          console.log(
            "üåç   ai_restore_request:",
            localStorage.getItem("ai_restore_request")
          );

          // UI state check
          const aiBtn = document.getElementById("aiBtn");
          if (aiBtn) {
            console.log("üåç AI Button state after call:");
            console.log("üåç   display:", aiBtn.style.display);
            console.log("üåç   classes:", Array.from(aiBtn.classList));
            console.log("üåç   disabled:", aiBtn.disabled);
          } else {
            console.log("üåç AI Button: NOT FOUND");
          }
        }

        // PHASE 6: DELAYED STATE VERIFICATION
        if ($DebugTestMode) {
          console.log("üåç === PHASE 6: SCHEDULING DELAYED VERIFICATION ===");
        }

        [100, 250, 500, 1000, 2000].forEach((delay, index) => {
          setTimeout(() => {
            if ($DebugTestMode) {
              console.log(
                `üåç ‚è∞ [DELAYED CHECK ${index + 1}/5] After ${delay}ms:`
              );
              console.log(
                `üåç ‚è∞   aiMinimized: ${window.controlManager?.aiMinimized}`
              );
              console.log(
                `üåç ‚è∞   aiRestoring: ${window.controlManager?.aiRestoring}`
              );
              console.log(
                `üåç ‚è∞   control_ai_minimized: ${localStorage.getItem(
                  "control_ai_minimized"
                )}`
              );
              console.log(
                `üåç ‚è∞   ai_restore_request: ${
                  localStorage.getItem("ai_restore_request") ? "EXISTS" : "NONE"
                }`
              );

              if (aiBtn) {
                console.log(`üåç ‚è∞   Button display: ${aiBtn.style.display}`);
              }
            }
          }, delay);
        });

        // PHASE 7: ERROR RECOVERY (if needed)
        if (callError) {
          if ($DebugTestMode) {
            console.log("üåç === PHASE 7: ERROR RECOVERY ===");
            console.log("üÜò Attempting error recovery...");
          }

          try {
            if (window.controlManager.onAIRestoreFailed) {
              if ($DebugTestMode) {
                console.log("üÜò Calling onAIRestoreFailed...");
              }
              window.controlManager.onAIRestoreFailed();
              if ($DebugTestMode) {
                console.log("üÜò onAIRestoreFailed completed");
              }
            } else {
              if ($DebugTestMode) {
                console.log("üÜò onAIRestoreFailed method not available");
              }
            }
          } catch (recoveryError) {
            if ($DebugTestMode) {
              console.error("‚ùå Recovery failed:", recoveryError);
              console.error("‚ùå Recovery error stack:", recoveryError.stack);
            }
          }
        }

        // FINAL SUMMARY
        if ($DebugTestMode) {
          console.log("üåç === FINAL SUMMARY ===");
          console.log(
            "üåç Global function completion timestamp:",
            new Date().toISOString()
          );
          console.log(
            "üåç Total execution time:",
            Date.now() - callStartTime,
            "ms"
          );
          console.log("üåç Call successful:", !callError);
          console.log("üåç Call result:", callResult);
          console.log("üåç Error occurred:", !!callError);
          if (callError) {
            console.log("üåç Error summary:", callError.message);
          }
          console.log(
            "üåçüåçüåç === ULTRA-ENHANCED GLOBAL RESTORE AI COMPLETE ==="
          );
        }
      }
      function captureScreenshot() {
        if ($DebugTestMode) {
          console.log("üéØ captureScreenshot global function called");
        }
        if (window.controlManager) {
          window.controlManager.captureScreenshot();
        } else {
          if ($DebugTestMode) {
            console.error("‚ùå controlManager not available");
          }
        }
      }

      function getTranscriptWords() {
        if ($DebugTestMode) {
          console.log("üéØ getTranscriptWords global function called");
        }
        if (window.controlManager) {
          window.controlManager.getTranscriptWords();
        } else {
          if ($DebugTestMode) {
            console.error("‚ùå controlManager not available");
          }
        }
      }

      function closeAll() {
        if ($DebugTestMode) {
          console.log("üéØ closeAll global function called");
        }
        if (window.controlManager) {
          window.controlManager.closeAll();
        } else {
          if ($DebugTestMode) {
            console.error("‚ùå controlManager not available");
          }
        }
      }

      function broadcastListeningState(newState, status = null) {
        isListening = newState;
        window.isListening = newState;

        // Broadcast to control bar
        const event = new CustomEvent("listeningStateChanged", {
          detail: {
            isListening: newState,
            status: status || (newState ? "üé§ Listening..." : "Ready"),
            timestamp: Date.now(),
          },
        });
        window.dispatchEvent(event);
      }

      function handleRightClick(event) {
        if ($DebugTestMode) {
          console.log("üéØ handleRightClick global function called");
        }
        event.preventDefault();
        if (window.controlManager) {
          window.controlManager.toggleSettingsMenu();
        } else {
          if ($DebugTestMode) {
            console.error("‚ùå controlManager not available");
          }
        }
      }

      function openSettings() {
        if ($DebugTestMode) {
          console.log("üéØ openSettings global function called");
        }
        if (window.controlManager) {
          window.controlManager.openSettings();
        } else {
          if ($DebugTestMode) {
            console.error("‚ùå controlManager not available");
          }
        }
      }

      // Initialize when DOM is loaded
      document.addEventListener("DOMContentLoaded", () => {
        try {
          window.controlManager = new ControlWindowManager();
          if ($DebugTestMode) {
            console.log("‚úÖ ControlWindowManager created successfully");
            console.log(
              "‚úÖ window.controlManager:",
              typeof window.controlManager
            );
            console.log(
              "‚úÖ Available methods:",
              Object.keys(window.controlManager).filter(
                (k) => typeof window.controlManager[k] === "function"
              )
            );
          }
        } catch (error) {
          if ($DebugTestMode) {
            console.error("‚ùå Failed to create ControlWindowManager:", error);
            console.error("‚ùå Error stack:", error.stack);
          }
        }
        if ($DebugTestMode) {
          console.log("üöÄ DOM loaded, initializing ControlWindowManager...");
          console.log("üöÄ NATIVE AUDIO MODE ENABLED");
          console.log("üöÄ Current timestamp:", new Date().toISOString());
          console.log("üöÄ Document ready state:", document.readyState);
        }

        const btn = document.getElementById("listenBtn");
        btn.disabled = true; // Disable until ready
        btn.textContent = "Loading Native Audio...";

        // Check if main renderer is ready AND native audio is available
        const checkMainRenderer = setInterval(() => {
          if (
            window.startListening &&
            typeof window.startListening === "function"
          ) {
            // Additional check for native audio capability
            if (window.electronAPI?.getScreenCaptureSource) {
              clearInterval(checkMainRenderer);
              btn.disabled = false;
              btn.textContent = "‚ñ∂ Listen";
              btn.onclick = toggleListening; // Set up click handler

              if ($DebugTestMode) {
                console.log("‚úÖ Native audio capability confirmed");
              }
            } else {
              // Fallback mode
              clearInterval(checkMainRenderer);
              btn.disabled = false;
              btn.textContent = "‚ñ∂ Listen (Fallback)";
              btn.onclick = toggleListening;

              if ($DebugTestMode) {
                console.warn("‚ö†Ô∏è Native audio not available, using fallback");
              }
            }
          }
        }, 100);

        if ($DebugTestMode) {
          console.log(
            "‚úÖ Enhanced persistent control window initialized with EXTENSIVE debug logging"
          );
        }
      });

      // Save settings before unload
      window.addEventListener("beforeunload", () => {
        if ($DebugTestMode) {
          console.log("üëã Window unloading, saving settings...");
        }
        if (window.controlManager) {
          window.controlManager.saveSettings();
        }
      });

      // Handle page visibility changes
      document.addEventListener("visibilitychange", () => {
        if ($DebugTestMode) {
          console.log("üëÅÔ∏è Visibility changed, hidden:", document.hidden);
        }
        if (window.controlManager && !document.hidden) {
          window.controlManager.ensureWindowVisibility();
        }
      });

      // Enhanced window visibility checker
      setInterval(() => {
        if (isListening) {
          // Check if window is actually visible
          const isVisible =
            document.visibilityState === "visible" &&
            !document.hidden &&
            document.body.style.display !== "none" &&
            document.body.style.visibility !== "hidden";

          if (!isVisible) {
            if ($DebugTestMode) {
              console.warn(
                "Control window not visible while listening, fixing..."
              );
            }

            // Force visibility
            document.body.style.display = "flex";
            document.body.style.visibility = "visible";
            document.body.style.opacity = "1";

            // Request main process to fix window
            if (window.electronAPI?.ensureControlWindowVisible) {
              window.electronAPI.ensureControlWindowVisible();
            }
          }
        }
      }, 1000);

      // üîß NEW: Listen for state changes from main renderer
      window.addEventListener("listeningStateChanged", (event) => {
        const newState = event.detail.isListening;
        const status = event.detail.status;

        // Update control manager state
        if (window.controlManager) {
          window.controlManager.isListening = newState;
        }

        // Update UI
        const btn = document.getElementById("listenBtn");
        // const statusDot = document.getElementById("statusDot");
        //const statusText = document.getElementById("statusText");

        if (btn) {
          btn.textContent = newState ? "‚è∏ Stop" : "‚ñ∂ Listen";
          if (newState) {
            btn.classList.add("active");
          } else {
            btn.classList.remove("active");
          }
        }

        /*if (statusDot) {
          if (newState) {
            statusDot.classList.add("active");
          } else {
            statusDot.classList.remove("active");
          }
        }*/

        /*if (statusText) {
          statusText.textContent = status;
        }*/
      });

      let isExpanded = false;
      let expandTimeout = null;
      let collapseTimeout = null;

      // Function to expand
      async function expandWindow() {
        if (!isExpanded) {
          if (expandTimeout) clearTimeout(expandTimeout);

          expandTimeout = setTimeout(async () => {
            if ($DebugTestMode) {
              console.log("üéõÔ∏è Expanding window");
            }

            try {
              const result = await window.electronAPI.expandControlWindow();
              if (result.success) {
                isExpanded = true;
                document.body.classList.add("expanded");
              }
            } catch (error) {
              if ($DebugTestMode) {
                console.error("‚ùå Error expanding window:", error);
              }
            }
          }, 50);
        }
      }

      // Function to collapse
      async function collapseWindow() {
        if (isExpanded) {
          if (collapseTimeout) clearTimeout(collapseTimeout);

          collapseTimeout = setTimeout(async () => {
            if ($DebugTestMode) {
              console.log("üéõÔ∏è Collapsing window");
            }

            try {
              const result = await window.electronAPI.collapseControlWindow();
              if (result.success) {
                isExpanded = false;
                document.body.classList.remove("expanded");
              }
            } catch (error) {
              if ($DebugTestMode) {
                console.error("‚ùå Error collapsing window:", error);
              }
            }
          }, 200);
        }
      }

      // Clear any pending timeouts
      function clearTimeouts() {
        if (expandTimeout) {
          clearTimeout(expandTimeout);
          expandTimeout = null;
        }
        if (collapseTimeout) {
          clearTimeout(collapseTimeout);
          collapseTimeout = null;
        }
      }

      /*document.addEventListener("DOMContentLoaded", () => {
        const container = document.querySelector(".container_wrapper");

        const container2 = document.querySelector(".body");
        container2.addEventListener("mouseenter", (e) => {
          if ($DebugTestMode) {
            console.log("Mouse entered container");
          }
          clearTimeouts();
          expandWindow();
          container.classList.add("drag");
        });

        container2.addEventListener("mouseleave", (e) => {
          if ($DebugTestMode) {
            console.log("Mouse left container");
          }
          clearTimeouts();
          collapseWindow();
          container.classList.remove("drag");
        });

        if ($DebugTestMode) {
          console.log("üéØ Mouse event listeners attached to container");
        }
      });*/
      // Handle when window regains focus
      window.addEventListener("focus", () => {
        // Don't auto-expand on focus, wait for mouse movement
      });
    </script>

    <script src="enhanced-audio-capture.js"></script>
    <script src="main-renderer.js"></script>
  </body>
</html>
